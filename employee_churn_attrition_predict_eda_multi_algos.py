# -*- coding: utf-8 -*-
"""employee-churn-attrition-predict-eda-multi-algos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jh4qpSHTZeQq-hjIsJpMQ9vPFvEumJLw

# <p style="background-color:#B61151;font-family:newtimeroman;color:#FFF9ED;font-size:150%;text-align:center;border-radius:10px 10px;">EMPLOYEE CHURN ANALYSIS PROJECT</p>

![image.png](attachment:image.png)

**Image credit:** [VantageCircle](https://blog.vantagecircle.com/employee-attrition/)

<a id="toc"></a>

## <h3 style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;" class="list-group-item list-group-item-action active" data-toggle="list" role="tablist" aria-controls="home">TABLE OF CONTENTS</h3>

* [   PREFACE](#0)
* [1) DATA](#1)
    * [1.1 Context](#1.1)
    * [1.2 About the Features](#1.2) 
    * [1.3 What the Problem is](#1.3) 
    * [1.4 Project Structure & Tasks](#1.4) 
* [2) LIBRARIES NEEDED IN THE STUDY](#2)
    * [2.1 User Defined Functions](#2.1)
* [3) ANALYSIS](#3)
    * [3.1) Loading & Reading the Data](#3)
* [4) EXPLORATORY DATA ANALYSIS (EDA) & VISUALIZATION](#4)
    * [4.1 - A General Look at the Data](#4.1)
    * [4.2 - The Examination of Features](#4.2)
* [5) DATA VISUALIZATION](#5)          
    * [5.1 - Employees_Left](#5.1)
    * [5.2 - Number of Projects](#5.2)
    * [5.3 - Time Spent in the Company](#5.3)
    * [5.4 - Subplots of features](#5.4)
* [6) DATA PRE-PROCESSING](#6)          
    * [6.1 - Label Encoding](#6.1)
    * [6.2 - Scalling](#6.2)
* [7 - CLUSTER ANALYSIS](#7)
* [8 - MODEL BUILDING](#8)
    * [8.1 - Spliting Data as Train & Test](#8.1)
    * [8.2 - Best Model Scores with PyCaret](#8.2)        
    * [8.3 - Gradient Boosting Classifier](#8.3)
        * [8.3.1 Model Building](#8.3.1)
        * [8.3.2 Evaluating Model Performance](#8.3.2)
        * [8.3.3 Feature Importance for Gradient Boosting Model](#8.3.3) 
        * [8.3.4 Gradient Boosting Classifier Cross Validation](#8.3.4)
        * [8.3.5 Gradient Boosting Classifier GridSearchCV](#8.3.5)
        * [8.3.6 Gradient Boosting Classifier ROC (Receiver Operating Curve) & AUC (Area Under Curve)](#8.3.6)            
        * [8.3.7 Prediction](#8.3.7)        
    * [8.4 - KNeighbors Classifier](#8.4) 
        * [8.4.1 Model Building](#8.4.1)
        * [8.4.2 Evaluating Model Performance](#8.4.2)
        * [8.4.3 KNeighbors Classifier Cross Validation](#8.4.3) 
        * [8.4.4 Elbow Method for Choosing Reasonable K Values](#8.4.4)
        * [8.4.5 KNeighbors Classifier GridsearchCV for Choosing Reasonable K Values](#8.4.5)
        * [8.4.6 KNeighbors Classifier ROC (Receiver Operating Curve) and AUC (Area Under Curve)](#8.4.6)            
        * [8.4.7 Prediction](#8.4.7)         
    * [8.5 - Random Forest Classifier](#8.5)
        * [8.5.1 Model Building](#8.5.1)
        * [8.5.2 Evaluating Model Performance](#8.5.2)
        * [8.5.3 Feature Importance for Random Forest Model](#8.5.3) 
        * [8.5.4 Random Forest Classifier Cross Validation](#8.5.4)
        * [8.5.5 Random Forest Classifier GridSearchCV](#8.5.5)
        * [8.5.6 Random Forest Classifier ROC (Receiver Operating Curve) and AUC (Area Under Curve)](#8.5.6)            
        * [8.5.7 Prediction](#8.5.7)     
    * [8.6 - CatBoost Classifier](#8.6)
        * [8.6.1 Model Building](#8.6.1)
        * [8.6.2 Evaluating Model Performance](#8.6.2)
        * [8.6.3 Feature Importance for CatBoost Model](#8.6.3) 
        * [8.6.4 CatBoost Classifier Cross Validation](#8.6.4)
        * [8.6.5 CatBoost Classifier GridSearchCV](#8.6.5)
        * [8.6.6 CatBoost Classifier ROC (Receiver Operating Curve) and AUC (Area Under Curve)](#8.6.6)            
        * [8.6.7 Prediction](#8.6.7)     
* [9) THE COMPARISON OF MODELS](#9)       
* [10) MODEL DEPLOYMENT](#10)
    * [10.1 - Save and Export the Model as .pkl](#10.1)
    * [10.2 - Save and Export Variables as .pkl](#10.2)<br>
**Note: There may be some additional sub-tasks associated with each task, you will see them in order during the course of the work.*    
* [11) REFERENCES](#11)
* [12) FURTHER READINGS](#12)

<a id="0"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">PREFACE</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

Welcome to "***Employee Churn Analysis Project***". This is the second project of Capstone Project Series, which you will be able to build your own classification models for a variety of business settings. 

Also you will learn what Employee Churn is?, How it is different from customer churn, Exploratory Data Analysis (EDA) and visualization of employee churn dataset using ***matplotlib*** and ***seaborn***, ***plotly express*** model building and evaluation using python ***scikit-learn*** package. 

You will be able to implement classification techniques in Python. Using Scikit-Learn allowing you to successfully make predictions with the Random Forest, Gradient Descent Boosting , KNN algorithms.

At the end of the project, you will have the opportunity to deploy your model using *Streamlit*.

Before diving into the project, please take a look at the determines and project structure.

- NOTE: This project assumes that you already know the basics of coding in Python and are familiar with model deployement as well as the theory behind K-Means, Gradient Boosting , KNN, Random Forest, and Confusion Matrices. You can try more models and methods beside these to improve your model metrics.

<a id="1"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">1 - DATA</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

In this project you have HR data of a company. A study is requested from you to predict which employee will churn by using this data.

The HR dataset has 14,999 samples with various information about the employees. In the given dataset, you have two types of employee one who stayed and another who left the company. This given dataset will be used to predict when employees are going to quit by understanding the main drivers of employee churn.

**For a better understanding and more information, please refer to [DataCamp](https://www.datacamp.com/community/tutorials/predicting-employee-churn-python) and [Kaggle Website](https://www.kaggle.com/kadirduran/hr-dataset)**

<a id="1.1"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:left; border-radius:10px 10px;">1.1 Context</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#e9a1ed" data-toggle="popover">Table of Contents</a>

**"Analyze employee churn. Find out why employees are leaving the company, and learn to predict who will leave the company.." [DataCamp](https://www.datacamp.com/community/tutorials/predicting-employee-churn-python)**

Employee turn-over (also known as "employee churn") is a costly problem for companies. The true cost of replacing an employee can often be quite large. A study by the Center for American Progress found that companies typically pay about one-fifth of an employeeâ€™s salary to replace that employee, and the cost can significantly increase if executives or highest-paid employees are to be replaced. In other words, the cost of replacing employees for most employers remains significant. This is due to the amount of time spent to interview and find a replacement, sign-on bonuses, and the loss of productivity for several months while the new employee gets accustomed to the new role.

In the past, most of the focus on the "rates" such as attrition rate and retention rates. HR Managers compute the previous rates try to predict the future rates using data warehousing tools. These rates present the aggregate impact of churn, but this is the half picture. Another approach can be the focus on individual records in addition to aggregate.

There are lots of case studies on customer churn are available. In customer churn, you can predict who and when a customer will stop buying. Employee churn is similar to customer churn. It mainly focuses on the employee rather than the customer. Here, you can predict who, and when an employee will terminate the service. Employee churn is expensive, and incremental improvements will give significant results. It will help us in designing better retention plans and improving employee satisfaction.

<a id="1.2"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:left; border-radius:10px 10px;">1.2 About The Features</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#e9a1ed" data-toggle="popover">Table of Contents</a>

**You can describe 10 attributes (features) in detail as:**

- ***satisfaction_level:*** It is employee satisfaction point, which ranges from 0-1.
- ***last_evaluation:*** It is evaluated performance by the employer, which also ranges from 0-1.
- ***number_projects:*** How many of projects assigned to an employee?
- ***average_monthly_hours:*** How many hours in averega an employee worked in a month?
- ***time_spent_company:*** time_spent_company means employee experience. The number of years spent by an employee in the company.
- ***work_accident:*** Whether an employee has had a work accident or not.
- ***promotion_last_5years:*** Whether an employee has had a promotion in the last 5 years or not.
- ***Departments:*** Employee's working department/division.
- ***Salary:*** Salary level of the employee such as low, medium and high.
- ***left:*** Whether the employee has left the company or not.

<a id="1.3"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:left; border-radius:10px 10px;">1.3 What The Problem Is</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#e9a1ed" data-toggle="popover">Table of Contents</a>

First of all, to observe the structure of the data, outliers, missing values and features that affect the target variable, you must use exploratory data analysis and data visualization techniques. 

Then, you must perform data pre-processing operations such as ***Scaling*** and ***Label Encoding*** to increase the accuracy score of Gradient Descent Based or Distance-Based algorithms. you are asked to perform ***Cluster Analysis*** based on the information you obtain during exploratory data analysis and data visualization processes. 

The purpose of clustering analysis is to cluster data with similar characteristics. You are asked to use the ***K-means*** algorithm to make cluster analysis. However, you must provide the K-means algorithm with information about the number of clusters it will make predictions. Also, the data you apply to the K-means algorithm must be scaled. In order to find the optimal number of clusters, you are asked to use the ***Elbow method***. Briefly, try to predict the set to which individuals are related by using K-means and evaluate the estimation results.

Once the data is ready to be applied to the model, you must ***split the data into train and test***. Then build a model to predict whether employees will churn or not. Train your models with your train set, test the success of your model with your test set. 

Try to make your predictions by using the algorithms ***Gradient Boosting Classifier***, ***K Neighbors Classifier***, ***Random Forest Classifier***. You can use the related modules of the ***scikit-learn*** library. You can use scikit-learn ***Confusion Metrics*** module for accuracy calculation. You can use the ***Yellowbrick*** module for model selection and visualization.

In the final step, you will deploy your model using Streamlit tool.

<a id="1.4"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:left; border-radius:10px 10px;">1.4 Project Structure & Tasks</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#e9a1ed" data-toggle="popover">Table of Contents</a>

#### 1. Exploratory Data Analysis
- Importing Modules
- Loading Dataset
- Data Insigts

#### 2. Data Visualization
- Employees Left
- Determine Number of Projects
- Determine Time Spent in Company
- Subplots of Features

#### 3. Data Pre-Processing
- Scaling
- Label Encoding

#### 4. Cluster Analysis
- Find the optimal number of clusters (k) using the elbow method for for K-means.
- Determine the clusters by using K-Means then Evaluate predicted results.

#### 5. Model Building
- Split Data as Train and Test set
- Built Gradient Boosting Classifier, Evaluate Model Performance and Predict Test Data
- Built K Neighbors Classifier and Evaluate Model Performance and Predict Test Data
- Built Random Forest Classifier and Evaluate Model Performance and Predict Test Data

#### 6. Model Deployement
- Save and Export the Model as .pkl
- Save and Export Variables as .pkl

<a id="2"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">2) LIBRARIES NEEDED IN THE STUDY<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>
"""

# Commented out IPython magic to ensure Python compatibility.
# if you need please install these libraries to import the following ones

!pip install pyforest
!pip install --user pycaret 
!pip install pandas_profiling
!pip install squarify
!pip install termcolor
!pip install catboost
!pip install pyclustertend

# 1-Import Libraies

import pandas_profiling
import pyforest

import ipywidgets
from ipywidgets import interact

import numpy as np
import pandas as pd 

import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline
import matplotlib.ticker as mticker
import squarify as sq

# Importing plotly and cufflinks in offline mode
import plotly.express as px
import cufflinks as cf
import plotly.offline
cf.go_offline()
cf.set_config_file(offline=False, world_readable=True)

# !pip install termcolor
import colorama
from colorama import Fore, Style  # maakes strings colored
from termcolor import colored
from termcolor import cprint

from wordcloud import WordCloud

import scipy.stats as stats
from scipy.cluster.hierarchy import linkage, dendrogram
import statsmodels.api as sm
import statsmodels.formula.api as smf
import missingno as msno 

import datetime as dt
from datetime import datetime

from pyclustertend import hopkins

from sklearn.cluster import KMeans, AgglomerativeClustering
from sklearn.compose import make_column_transformer
from sklearn.decomposition import PCA
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier, GradientBoostingRegressor 
from sklearn.ensemble import ExtraTreesRegressor, AdaBoostClassifier
from sklearn.feature_selection import SelectKBest, SelectPercentile, f_classif, f_regression, mutual_info_regression
from sklearn.impute import SimpleImputer, KNNImputer
from sklearn.linear_model import LinearRegression, Lasso, Ridge, ElasticNet
from sklearn.metrics import plot_confusion_matrix, r2_score, mean_absolute_error, mean_squared_error, classification_report 
from sklearn.metrics import confusion_matrix, accuracy_score, classification_report
from sklearn.metrics import make_scorer, precision_score, precision_recall_curve, plot_precision_recall_curve 
from sklearn.metrics import plot_roc_curve, roc_auc_score, roc_curve, f1_score, accuracy_score, recall_score
from sklearn.metrics import silhouette_samples,silhouette_score
from sklearn.metrics.cluster import adjusted_rand_score
from sklearn.model_selection import RandomizedSearchCV
from sklearn.model_selection import RepeatedStratifiedKFold, KFold, cross_val_predict, train_test_split
from sklearn.model_selection import StratifiedKFold, GridSearchCV, cross_val_score, cross_validate
from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsRegressor, KNeighborsClassifier
from sklearn.pipeline import make_pipeline, Pipeline
from sklearn.preprocessing import scale, StandardScaler, MinMaxScaler, RobustScaler
from sklearn.preprocessing import PolynomialFeatures, OneHotEncoder, PowerTransformer, LabelEncoder 
from sklearn.svm import SVR, SVC
from sklearn.tree import plot_tree, DecisionTreeClassifier
from yellowbrick.classifier import ClassificationReport

from xgboost import XGBRegressor, XGBClassifier, plot_importance

# Ignore Warnings
import warnings
warnings.filterwarnings("ignore")
warnings.warn("this will not show")

# Figure&Display options
plt.rcParams["figure.figsize"] = (10,6)
pd.set_option('max_colwidth',200)
pd.set_option('display.max_rows', 1000)
pd.set_option('display.max_columns', 200)
pd.set_option('display.float_format', lambda x: '%.3f' % x)

# To suppress Pandas Future warning
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

"""<a id="2.1"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">2.1 User Defined Functions<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>
    
**We have defined some useful user defined functions.**
"""

## Some Useful Functions

###############################################################################

def missing_values(df):
    missing_number = df.isnull().sum().sort_values(ascending = False)
    missing_percent = (df.isnull().sum() / df.isnull().count()).sort_values(ascending = False)
    missing_values = pd.concat([missing_number, missing_percent], axis = 1, keys = ['Missing_Number', 'Missing_Percent'])
    return missing_values[missing_values['Missing_Number'] > 0]

###############################################################################

def first_looking(df):
    print(colored("Shape:", attrs=['bold']), df.shape,'\n', 
          colored('*'*100, 'red', attrs = ['bold']),
          colored("\nInfo:\n", attrs = ['bold']), sep = '')
    print(df.info(), '\n', 
          colored('*'*100, 'red', attrs = ['bold']), sep = '')
    print(colored("Number of Uniques:\n", attrs = ['bold']), df.nunique(),'\n',
          colored('*'*100, 'red', attrs = ['bold']), sep = '')
    print(colored("Missing Values:\n", attrs=['bold']), missing_values(df),'\n', 
          colored('*'*100, 'red', attrs = ['bold']), sep = '')
    print(colored("All Columns:", attrs = ['bold']), list(df.columns),'\n', 
          colored('*'*100, 'red', attrs = ['bold']), sep = '')

    df.columns = df.columns.str.lower().str.replace('&', '_').str.replace(' ', '_')
    print(colored("Columns after rename:", attrs = ['bold']), list(df.columns),'\n',
          colored('*'*100, 'red', attrs = ['bold']), sep = '')  
    print(colored("Columns after rename:", attrs = ['bold']), list(df.columns),'\n',
          colored('*'*100, 'red', attrs = ['bold']), sep = '')
    print(colored("Descriptive Statistics \n", attrs = ['bold']), df.describe().round(2),'\n',
          colored('*'*100, 'red', attrs = ['bold']), sep = '') # Gives a statstical breakdown of the data.
    print(colored("Descriptive Statistics (Categorical Columns) \n", attrs = ['bold']), df.describe(include = object).T,'\n',
          colored('*'*100, 'red', attrs = ['bold']), sep = '') # Gives a statstical breakdown of the data.
    
def multicolinearity_control(df):
    feature = []
    collinear = []
    for col in df.corr().columns:
        for i in df.corr().index:
            if (abs(df.corr()[col][i]) > .9 and abs(df.corr()[col][i]) < 1):
                    feature.append(col)
                    collinear.append(i)
                    print(colored(f"Multicolinearity alert in between:{col} - {i}", 
                                  "red", attrs = ['bold']), df.shape,'\n',
                                  colored('*'*100, 'red', attrs = ['bold']), sep = '')

def duplicate_values(df):
    print(colored("Duplicate check...", attrs = ['bold']), sep = '')
    print("There are", df.duplicated(subset = None, keep = 'first').sum(), "duplicated observations in the dataset.")
    duplicate_values = df.duplicated(subset = None, keep = 'first').sum()
    if duplicate_values > 0:
        df.drop_duplicates(keep = 'first', inplace = True)
        print(duplicate_values, colored(" Duplicates were dropped!"),'\n',
              colored('*'*100, 'red', attrs = ['bold']), sep = '')
#     else:
#         print(colored("There are no duplicates"),'\n',
#               colored('*'*100, 'red', attrs = ['bold']), sep = '')     
        
# def drop_columns(df, drop_columns):
#     if drop_columns != []:
#         df.drop(drop_columns, axis = 1, inplace = True)
#         print(drop_columns, 'were dropped')
#     else:
#         print(colored('We will now check the missing values and if necessary, the related columns will be dropped!', attrs = ['bold']),'\n',
#               colored('*'*100, 'red', attrs = ['bold']), sep = '')
        
def drop_null(df, limit):
    print('Shape:', df.shape)
    for i in df.isnull().sum().index:
        if (df.isnull().sum()[i] / df.shape[0]*100) > limit:
            print(df.isnull().sum()[i], 'percent of', i ,'null and were dropped')
            df.drop(i, axis = 1, inplace = True)
            print('new shape:', df.shape)       
    print('New shape after missing value control:', df.shape)
    
###############################################################################

# To view summary information about the columns

def first_look(col):
    print("column name    : ", col)
    print("--------------------------------")
    print("Per_of_Nulls   : ", "%", round(df[col].isnull().sum() / df.shape[0]*100, 2))
    print("Num_of_Nulls   : ", df[col].isnull().sum())
    print("Num_of_Uniques : ", df[col].nunique())
    print("Duplicates     : ", df.duplicated(subset = None, keep = 'first').sum())
    print(df[col].value_counts(dropna = False))
    
###############################################################################

def fill_most(df, group_col, col_name):
    '''Fills the missing values with the most existing value (mode) in the relevant column according to single-stage grouping'''
    for group in list(df[group_col].unique()):
        cond = df[group_col] == group
        mode = list(df[cond][col_name].mode())
        if mode != []:
            df.loc[cond, col_name] = df.loc[cond, col_name].fillna(df[cond][col_name].mode()[0])
        else:
            df.loc[cond, col_name] = df.loc[cond, col_name].fillna(df[col_name].mode()[0])
    print("Number of NaN : ",df[col_name].isnull().sum())
    print("------------------")
    print(df[col_name].value_counts(dropna = False))
    
###############################################################################    
# show values in bar graphic

def show_values_on_bars(axs):
    def _show_on_single_plot(ax):        
        for p in ax.patches:
            _x = p.get_x() + p.get_width() / 2
            _y = p.get_y() + p.get_height()
            value = '{:.2f}'.format(p.get_height())
            ax.text(_x, _y, value, ha="center") 
    if isinstance(axs, np.ndarray):
        for idx, ax in np.ndenumerate(axs):
            _show_on_single_plot(ax)
    else:
        _show_on_single_plot(axs)

"""<a id="3"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">3) ANALYSIS<p>

<a id="3.1"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">3.1 Loading & Reading the Data<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

**How to read and assign the dataset as df: You can [Visit Here](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html) (You can define it as what you want instead of df)**

**Let's first load the required HR dataset using pandas's "read_csv" function.**
"""

df0 = pd.read_csv('../input/hr-dataset/HR_Dataset.csv')
df = df0.copy()
df.head(3)

df.tail(3)

df.sample(3)

"""<a id="4"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">4) DATA CLEANING & EXPLORATORY DATA ANALYSIS (EDA)<p>

**Exploratory Data Analysis is an initial process of analysis, in which you can summarize characteristics of data such as pattern, trends, outliers, and hypothesis testing using descriptive statistics and visualization.**

<a id="4.1"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">4.1 - A General Look at the Data<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>
    
**Pandas profiling is an open source Python module with which we can quickly do an exploratory data analysis with just a few lines of code. Similarly, for EDA, profile_report() is One-Line Magical Code creating reports in the interactive HTML format which is quite easy to understand and analyze the data. In short, at the first hand, what pandas profiling does is to save us all the work of visualizing and understanding the distribution of each variable.**

**For a better understanding and more information, please refer to [Source 1](https://www.analyticsvidhya.com/blog/2021/06/generate-reports-using-pandas-profiling-deploy-using-streamlit/) & [Source 2](https://towardsdatascience.com/exploratory-data-analysis-with-pandas-profiling-de3aae2ddff3)**
"""

df.profile_report()

first_looking(df)
duplicate_values(df)
print(colored("Shape:", attrs = ['bold']), df.shape,'\n', colored('*'*100, 'red', attrs = ['bold']))

"""***According to the basic examinations on the dataset;***

**- There has been a classification problem.**<br>
**- We are going to make classification on the target variable "left".**<br>
**- So a model will be built to get the best classification on the "left" column.**<br>
**- Moreover, being balanced of "left" column or not will be take into consideration meticolously.**<br>
**- The dataset has 10 columns and 11991 observations after dropping of duplicated observations.**<br>
**- 8 columns contain numerical values and 2 columns contain categorical values.**<br> 
**- There seems to be no missing value.** 
"""

df.columns

df.rename({'departments_': 'department'}, axis=1, inplace=True)
df.head(1)

# Alternative code
# last_column = df.pop('left')
# df.insert(9, 'left', last_column)
# df.head(1)

df = df[['satisfaction_level', 'last_evaluation', 'number_project',
       'average_montly_hours', 'time_spend_company', 'work_accident',
       'promotion_last_5years', 'department', 'salary', 'left']]
df.head(1)

"""**The 'left' column, which is the target column, was moved from where it is to the end. In this way, it will make more comfortable the analysis for the evaluation of analysis.**

<a id="4.2"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">4.2 - The Examination of Features<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>
    
**In the given dataset, we have two types of employee one who stayed and another who left the company. So, we can divide data into two groups and compare their characteristics. Here, we can find the average of both the groups using groupby() and mean() function.**

**- Before jumping into modelling, let's try to get some information by examining the columns in the dataset one by one.**

### 'left' Column-Target Column
"""

cprint("Have a First Look to 'left' Column",'green')
first_look('left')

# df['left'].value_counts().iplot(kind="bar", title = '"left" Column Distribution')

fig = px.pie(df, values = df['left'].value_counts(), 
             names = (df['left'].value_counts()).index, 
             title = '"left" Column Distribution')
fig.show()

y = df['left']
print(f'Percentage of left-1: % {round(y.value_counts(normalize=True)[1]*100,2)} --> \
({y.value_counts()[1]} observations for left-1)\nPercentage of left-0: % {round(y.value_counts(normalize=True)[0]*100,2)} --> ({y.value_counts()[0]} observations for left-0)')

"""**- The target column, 'left', has binary type values.**<br>
**- There has been an imbalanced data for the analysis.**<br>
**- Almost 17% of the employees prefered NOT to continue with the company and left.**<br>
**- 1991 employees left.**<br>
**- Almost 83% of the employees prefered to continue with the company and stayed.**<br>
**- 10000 employees stayed.**
"""

df.groupby('left').mean()

cprint('Dataset describe results according to the "left==1" condition','green')
df[df['left'] == 1].describe().T.style.background_gradient(subset = ['mean','min','50%', 'max'], cmap = 'RdPu')

cprint('Dataset describe results according to the "left==0" condition','green')
df[df['left'] == 0].describe().T.style.background_gradient(subset = ['mean','min','50%', 'max'], cmap = 'RdPu')

"""### 'satisfaction_level' Column"""

cprint("Have a First Look to 'left' Column",'green')
first_look('satisfaction_level')

df['satisfaction_level'].value_counts().iplot(kind="bar", title = '"satisfaction_level" Column Distribution')

px.histogram(df, x = df['satisfaction_level'], color='left', marginal = "box", hover_data = df.columns, 
             title = 'satisfaction_level and left')

pd.crosstab(df['satisfaction_level'], df['left']).iplot(kind='bar', title = 'satisfaction_level and left')

sns.scatterplot(data=df, x="satisfaction_level", y="left", hue="left");

df.corr(method='pearson')[7:]

"""**- Although it is expected that there should be a linear relationship between 'satisfaction_level' and 'left', it does not seem clearly on the graph due to the type of "left" feature.**<br> 
**- Those with a 'satisfaction_level' value of around 0.1 are more likely to be 'left'.**<br> 
**- There is a significant increase in the number of those labeled 'left' whose 'satisfaction_level' value is between 0.55. In fact, the number of those who left their companies exceeds that of the ones who not.**<br> 
**- When the 'satisfaction_level' value is around between 0.7 and 0.9, there is an increase in the number of those who left.**<br> 
**- Except for these intervals, no matter how low the satisfaction_level was, the employees continued their work.**

### 'last_evaluation' Column
"""

cprint("Have a First Look to 'last_evaluation' Column",'green')
first_look('last_evaluation')

df['last_evaluation'].value_counts().iplot(kind="bar", title = '"last_evaluation" Column Distribution')

px.histogram(df, x = df['last_evaluation'], color='left', marginal = "box", hover_data = df.columns, 
             title = 'last_evaluation and left')

pd.crosstab(df['last_evaluation'], df['left']).iplot(kind='bar', title = 'last_evaluation and left')

"""**- There is a local increase between 0.45-0.6 and 0.8-1 in the 'last_evaluation' values, as in 'satisfaction_level' values. There is an increase in the number of people who quit their jobs in these intervals.**

### 'number_project' Column
"""

cprint("Have a First Look to 'number_project' Column",'green')
first_look('number_project')

df['number_project'].value_counts().iplot(kind="bar", title = '"number_project" Column Distribution')

fig = px.pie(df, values = df['number_project'].value_counts(), 
             names = (df['number_project'].value_counts()).index, 
             title = '"number_project" Column Distribution')
fig.show()

px.histogram(df, x = df['number_project'], color='left', marginal = "box", hover_data = df.columns, 
             title = 'number_project and left')

pd.crosstab(df['number_project'], df['left']).iplot(kind='bar', title = 'number_project and left')

"""**It's clear that the employees who made 2, 6 and 7 projects are more inclined to leave their works. It's normal to expect employees who made more projects but not getting more salary or feeling more satisfaction to leave their works;however, those who left even though making less projects should be scrutinized more meticulously.**

### 'average_montly_hours' Column
"""

cprint("Have a First Look to 'average_montly_hours' Column",'green')
first_look('average_montly_hours')

df['average_montly_hours'].value_counts().iplot(kind="bar", title = '"average_montly_hours" Column Distribution')

px.histogram(df, x = df['average_montly_hours'], color='left', marginal = "box", hover_data = df.columns, 
             title = 'average_montly_hours and left')

pd.crosstab(df['average_montly_hours'], df['left']).iplot(kind='bar', title = 'average_montly_hours and left')

"""**- Looking at the 'average_montly_hours' values, there is a local increase in turnover in the 125-160 month working hours range and 210-290 monthly working hours.**<br> 
**- Those who work more than 290 hours per month are more likely to quit their jobs than those who do not.**

**How does workload affect employee churn?**
"""

plt.figure(figsize=(15, 8))
fig = sns.histplot(
    df,
    x="average_montly_hours", hue="left",
    multiple="stack",
    palette="light:m_r",
    edgecolor=".3",
    linewidth=.5
)
fig2 = fig.twinx()

fig.yaxis.set_label_position('left')
fig2.yaxis.set_label_position('right')

fig2.set_ylabel('frequency [%]')

for p in fig.patches:
    x=p.get_bbox().get_points()[:,0]
    y=p.get_bbox().get_points()[1,1]
    fig.annotate('{:.1f}%'.format(100.*y/len(df)), (x.mean(), y), 
            ha='center', va='bottom') # set the alignment of the text
fig2.grid(None)
fig2.set_ylim(0,100)

"""It can be stated that tendency to left company regarding work-load has five phases;
   - **Below 125 hours/month** there is **no churn**
   - **125-160 hours/month** churn rate **is highest**
   - **160-220 hours/month** churn rate **very low (neglectable)**
   - **220-288 hours/month** churn rate **high (has a bell shape)**
   - **Over 288 hours/month** churn rate **%100!!!**

### 'time_spend_company' Column
"""

cprint("Have a First Look to 'time_spend_company' Column",'green')
first_look('number_project')

df['time_spend_company'].value_counts().iplot(kind="bar", title = '"time_spend_company" Column Distribution')

fig = px.pie(df, values = df['time_spend_company'].value_counts(), 
             names = (df['time_spend_company'].value_counts()).index, 
             title = '"time_spend_company" Column Distribution')
fig.show()

px.histogram(df, x = df['time_spend_company'], color='left', marginal = "box", hover_data = df.columns, 
             title = 'time_spend_company and left')

pd.crosstab(df['time_spend_company'], df['left']).iplot(kind='bar', title = 'time_spend_company and left')

"""**- Looking at the 'time_spent_company' values, there is an increase in turnover in the 3rd working year, but this increase gradually decreases until the 6th working year.**

### 'work_accident' Column
"""

cprint("Have a First Look to 'work_accident' Column",'green')
first_look('work_accident')

df['work_accident'].value_counts().iplot(kind="bar", title = '"work_accident" Column Distribution')

fig = px.pie(df, values = df['work_accident'].value_counts(), 
             names = (df['work_accident'].value_counts()).index, 
             title = '"work_accident" Column Distribution')
fig.show()

px.histogram(df, x = df['work_accident'], color='left', marginal = "box", hover_data = df.columns, 
             title = 'work_accident and left')

pd.crosstab(df['work_accident'], df['left']).iplot(kind='bar', title = 'work_accident and left')

"""**- 'work_accident' column has binary type values.**
**- While the employees who don't get involved in accident are more likely to leave with a value of 22.84%, those  who get involved in accident are less likely to leave with a value of 6.02%.**  
**- Altough it does not appear to be a determining factor and needs to be examined carefully by looking at the conditions at workplace, companies' policies and etc.; in fact, it could be said that the left rate of those who have got involved in a work accident is proportionally lower than those who did NOT.**

### 'promotion_last_5years' Column
"""

cprint("Have a First Look to 'promotion_last_5years' Column",'green')
first_look('promotion_last_5years')

df['promotion_last_5years'].value_counts().iplot(kind="bar", title = '"promotion_last_5years" Column Distribution')

fig = px.pie(df, values = df['promotion_last_5years'].value_counts(), 
             names = (df['promotion_last_5years'].value_counts()).index, 
             title = '"promotion_last_5years" Column Distribution')
fig.show()

px.histogram(df, x = df['promotion_last_5years'], color='left', marginal = "box", hover_data = df.columns, 
             title = 'promotion_last_5years and left')

pd.crosstab(df['promotion_last_5years'], df['left']).iplot(kind='bar', title = 'promotion_last_5years and left')

"""**- 'promotion_last_5years' column has binary type values.**<br>
**- Receiving a promotion in the last 5 working years is not determinant in terms of leaving or continuing to work.**<br> 
**- However, the percentage of those who receive promotions, even if it is small, are higher than those who do not.**

### 'department' Column
"""

cprint("Have a First Look to 'department' Column",'green')
first_look('department')

df['department'].value_counts().iplot(kind="bar", title = '"department" Column Distribution')

fig = px.pie(df, values = df['department'].value_counts(), 
             names = (df['department'].value_counts()).index, 
             title = '"department" Column Distribution')
fig.show()

px.histogram(df, x = df['department'], color='left', marginal = "box", hover_data = df.columns, 
             title = 'department and left')

pd.crosstab(df['department'], df['left']).iplot(kind='bar', title = 'department and left')

"""**- It is not observed that the departments which require the employees to work alone have an effect on the decision of "left".**<br> 
**- It is seen that the left percentages of the departments are quite similar.**

### 'salary' Column
"""

cprint("Have a First Look to 'salary' Column",'green')
first_look('salary')

df['salary'].value_counts().iplot(kind="bar", title = '"salary" Column Distribution')

fig = px.pie(df, values = df['salary'].value_counts(), 
             names = (df['salary'].value_counts()).index, 
             title = '"salary" Column Distribution')
fig.show()

px.histogram(df, x = df['salary'], color='left', marginal = "box", hover_data = df.columns, 
             title = 'salary and left')

pd.crosstab(df['salary'], df['left']).iplot(kind='bar', title = 'salary and left')

"""**- Naturally as salary rises, churn rate decreeses**.<br>
**- Even if it is small, there is an increase in the form of high-medium-low according to the salary status.**

***Let's go on with the examination of numerical and categorical columns.***
"""

numerical= df.drop(['left'], axis=1).select_dtypes('number').columns

categorical = df.select_dtypes('object').columns

print(colored("Numerical Columns:", attrs=['bold']), list(df[numerical].columns),'\n',
              colored('-'*124, 'red', attrs=['bold']), sep='')
print(colored("Categorical Columns:", attrs=['bold']), list(df[categorical].columns),'\n',
              colored('-'*124, 'red', attrs=['bold']), sep='')

"""### categorical variables"""

df[categorical].head().T

df[categorical].describe().T.style.background_gradient(subset=['unique','freq','count'], cmap='RdPu')

df[categorical].nunique()

"""**It looks like there has NOT been a high cardinality issue.**"""

for i, col in enumerate(df[categorical].columns):
    fig = px.histogram(df[col], color=df["left"], width=800, height=800, title=col, pattern_shape=df["salary"], pattern_shape_sequence=["x", ".", "+"])
    fig.show()

sns.swarmplot(y="satisfaction_level", x="salary", hue="left", data=df, palette="husl");

sns.swarmplot(y="average_montly_hours", x="department", hue="left", data=df, palette="husl");

sns.swarmplot(y="number_project", x="department", hue="left", data=df, palette="husl");

sns.swarmplot(y="time_spend_company", x="department", hue="left", data=df, palette="husl");

"""**Now, let's examine crosstab outputs for each variable.**"""

for i, col in enumerate(df[categorical].columns):
    xtab = pd.crosstab(df[col], df["left"], normalize=True)
    print(colored('-'*40, 'red', attrs=['bold']), sep='')
    print(xtab*100)

"""### numerical variables"""

numerical= df.drop(['left'], axis = 1).select_dtypes('number').columns

categorical = df.select_dtypes('object').columns

print('---------------------')
print(f'Numerical Columns:  {df[numerical].columns}')
print(f'Categorical Columns: {df[categorical].columns}')
print('---------------------')

df[numerical].describe().T.style.background_gradient(subset = ['mean','std','50%','count'], cmap = 'RdPu')

df[numerical].iplot(kind = 'histogram', subplots = True, bins = 50)

for i in numerical:
    df[i].iplot(kind = 'box', title = i, boxpoints = 'all')

sns.pairplot(df, hue = "left", corner = True);

plt.figure(figsize=(14, 10))

# Getting the Upper Triangle of the co-relation matrix
matrix = np.triu(df.corr())

# using the upper triangle matrix as mask 
sns.heatmap(df.corr(), annot=True, cmap = sns.cubehelix_palette(8), mask=matrix)

plt.xticks(rotation=45);

df.corr()['left'].sort_values().drop('left').iplot(kind = 'barh', colors='purple');

df_temp = df.corr()

count = 'Done'
feature =[]
collinear= []
for col in df_temp.columns:
    for i in df_temp.index:
        if (df_temp[col][i] > .9 and df_temp[col][i] < 1) or (df_temp[col][i] < -.9 and df_temp[col][i] > -1) :
                feature.append(col)
                collinear.append(i)
                print(Fore.RED + f'\033[1mmulticolinearity alert in between\033[0m {col} - {i}')
        else:
            print(f'For {col} and {i}, there is NO multicollinearity problem') 

print('\033[1mThe number of strong corelated features:\033[0m', count)

df.columns

"""### Based on the examinations made above;

**- There is no multicollinearity problem among the features.**<br>
**- We have weak level correlation between the numerical features and the target column.**<br>
**- Also there is weak level correlation between the columns.**<br>
**- Target variable demonstrates a slight negative correlation with the variables of "satisfaction_level", "promotion_last_5years" and 'work_accident',**<br> 
**- Target variable of "left" demonstrates weak correlation with the variables of 'last_evaluation', 'number_project', 'average_montly_hours', 'time_spend_company', 'department' and 'salary'.**<br>
**- "satisfaction_level", even if it's quite small, has more influence on the decision to leave work with a negative value than other features.**<br>
**- The increase in spending time at workplace positively affects the decision to leave with the company.**

<a id="5"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">5) DATA VISUALIZATION<p>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>
    
**- Employees Left**<br>
**- Determine Number of Projects**<br>
**- Determine Time Spent in Company**<br>
**- Subplots of Features**<br>
----------
You can search for answers to the following questions using data visualization methods. Based on these responses, you can develop comments about the factors that cause churn.

**- How does the promotion status affect employee churn?**<br>
**- How does years of experience affect employee churn?**<br>
**- How does workload affect employee churn?**<br>
**- How does the salary level affect employee churn?**<br>

<a id="5.1"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">5.1 - A General Look at the Data<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

**Let's check how many employees were left?**<br>
**Here, you can plot a bar graph using Matplotlib. The bar graph is suitable for showing discrete variable counts.**
"""

cprint('"left" Column Distribution','green')
df.left.value_counts()

# with plotly

df['left'].value_counts().iplot(kind="bar", title = '"left" Column Distribution')

# with seaborn

plt.figure(figsize = (7,5))
sns.countplot(data = df, x = 'left');
for index,value in enumerate(df.left.value_counts()):
    plt.text(index, value, f'{value}', ha = 'center', va = 'bottom', fontsize = 13);

cprint('"left" Column Distribution','green')
fig = plt.figure(figsize = (11, 6))
ax = fig.add_axes([0, 0, 1, 1])
ax.bar(df.left.value_counts().index, df.left.value_counts().values, color = 'green')
plt.title('"left" Column Distribution')   
plt.xlabel('left') 
plt.ylabel('Number of Employees') 
for index,value in enumerate(df.left.value_counts()):
    plt.text(index, value, f'{value}', ha = 'center', va = 'bottom', fontsize = 13)
plt.show()

"""<a id="5.2"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">5.2 - Number of Projects<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

**Similarly, you can also plot a bar graph to count the number of employees deployed on how many projects?**
"""

cprint('"number_project" Column Distribution','green')
df.number_project.value_counts()

# with plotly

df['number_project'].value_counts().iplot(kind="bar", title = '"number_project" Column Distribution')

cprint('"number_project" Column Distribution','green')
fig = plt.figure(figsize = (11,6))
ax = fig.add_axes([0,0,1,1])
# x = df.number_project.value_counts().index
# y = df.number_project.value_counts().values
df.number_project.value_counts().plot(kind = "bar", color = "orange")
plt.title('"number_project" Column Distribution')   
plt.xlabel('number_project') 
plt.ylabel('Number of Employees')
plt.xticks(rotation = 0)
for index,value in enumerate(df.number_project.value_counts().sort_values(ascending=False)):
    plt.text(index, value, f'{value}', ha = 'center', va = 'bottom', fontsize = 13)
plt.show()

"""<a id="5.3"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">5.3 - Time Spent in the Company<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

**Similarly, you can also plot a bar graph to count the number of employees have based on how much experience?**
"""

cprint('"time_spend_company" Column Distribution','green')
df.time_spend_company.value_counts()

# with plotly

df['time_spend_company'].value_counts().iplot(kind="bar", title = '"time_spend_company" Column Distribution')

cprint('"time_spend_company" Column Distribution','green')
fig = plt.figure(figsize = (11,6))
ax = fig.add_axes([0,0,1,1])
df.time_spend_company.value_counts().plot(kind = "bar", color = "pink")
plt.title('"time_spend_company" Column Distribution')   
plt.xlabel('time_spend_company') 
plt.ylabel('Number of Employees')
plt.xticks(rotation = 0)
for index,value in enumerate(df.time_spend_company.value_counts().sort_values(ascending=False)):
    plt.text(index, value, f'{value}', ha = 'center', va = 'bottom', fontsize = 13)
plt.show()

"""<a id="5.4"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">5.4 - Subplots of Features<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

**You can use the methods of the matplotlib.**
"""

for i in df:
    df[i].iplot(kind = 'histogram', subplots = True, bins = 50)

"""<a id="6"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">6) DATA PRE-PROCESSING<p>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>
    
### Tasks in this section
**- Label Encoding**<br>
**- Scaling**

<a id="6.1"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">6.1 - Label Encoding<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

**Lots of machine learning algorithms require numerical input data, so you need to represent categorical columns in a numerical column. In order to encode this data, you could map each value to a number. e.g. Salary column's value can be represented as low:0, medium:1, and high:2. This process is known as label encoding, and sklearn conveniently will do this for you using LabelEncoder.**
"""

df1 = df.drop('left', axis = 1)
df1.head(1)

df1 = pd.get_dummies(df1, columns = ['department','salary'], drop_first = True)
df1.head(1)

"""<a id="6.2"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">6.2 - Scalling<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

**Some machine learning algorithms are sensitive to feature scaling while others are virtually invariant to it. Machine learning algorithms like linear regression, logistic regression, neural network, etc. that use gradient descent as an optimization technique require data to be scaled. Also distance algorithms like KNN, K-means, and SVM are most affected by the range of features. This is because behind the scenes they are using distances between data points to determine their similarity.**

### Scaling Types & Selecting Scaler:
    
  - **Min-Max Scaler (Normalization)** : Normalization is a scaling technique in which values are shifted and rescaled so that they end up ranging between 0 and 1. This Scaler responds well if the standard deviation is small and when a distribution is not Gaussian. This Scaler is sensitive to outliers. It is also known as Normalization.
  
  - **Standard Scaler** : Standardization is another scaling technique where the values are centered around the mean with a unit standard deviation. This means that the mean of the attribute becomes zero and the resultant distribution has a unit standard deviation. Assumes that data is normally distributed within each feature and scales them such that the distribution centered around 0, with a standard deviation of 1.
  
  - **Max Abs Scaler** : Scale each feature by its maximum absolute value. This estimator scales and translates each feature individually such that the maximal absolute value of each feature in the training set is 1.0. It does not shift/center the data and thus does not destroy any sparsity. On positive-only data, this Scaler behaves similarly to Min Max Scaler and, therefore, also suffers from the presence of significant outliers.

  - **Robust Scaler** : Robust to outliers. If our data contains many outliers, scaling using the mean and standard deviation of the data wonâ€™t work well. This Scaler removes the median and scales the data according to the quantile range. The centering and scaling statistics of this Scaler are based on percentiles and are therefore not influenced by a few numbers of huge marginal outliers.

  - **Quantile Transformer Scaler** : Transform features using quantiles information. This method transforms the features to follow a uniform or a normal distribution. Therefore, for a given feature, this transformation tends to spread out the most frequent values. It also reduces the impact of (marginal) outliers: this is, therefore, a robust pre-processing scheme. The cumulative distribution function of a feature is used to project the original values. Note that this transform is non-linear and may distort linear correlations between variables measured at the same scale but renders variables measured at different scales more directly comparable. This is also sometimes called as Rank scaler.
  
  - **Power Transformer Scaler** : The power transformer is a family of parametric, monotonic transformations that are applied to make data more Gaussian-like. This is useful for modeling issues related to the variability of a variable that is unequal across the range (heteroscedasticity) or situations where normality is desired. The power transform finds the optimal scaling factor in stabilizing variance and minimizing skewness through maximum likelihood estimation. Currently, Sklearn implementation of PowerTransformer supports the Box-Cox transform and the Yeo-Johnson transform. The optimal parameter for stabilizing variance and minimizing skewness is estimated through maximum likelihood. Box-Cox requires input data to be strictly positive, while Yeo-Johnson supports both positive or negative data.

  - **Unit Vector Scaler** : Scaling is done considering the whole feature vector to be of unit length. This usually means dividing each component by the Euclidean length of the vector (L2 Norm). In some applications (e.g., histogram features), it can be more practical to use the L1 norm of the feature vector. Like Min-Max Scaling, the Unit Vector technique produces values of range [0,1]. When dealing with features with hard boundaries, this is quite useful. For example, when dealing with image data, the colors can range from only 0 to 255.


[Click here for more on scaling.](https://towardsdatascience.com/all-about-feature-scaling-bcc0ad75cb35)    
"""

df1.head()

scaler = MinMaxScaler()
scaler.fit(df1)

#Store it separately for clustering
df1_scaled= scaler.transform(df1)

df1_scaled

"""<a id="7"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">7) CLUSTER ANALYSIS<p>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

**- Find the optimal number of clusters (k) using the elbow method for for K-means.**
**- Determine the clusters by using K-Means then Evaluate predicted results.**
---------

**- Cluster analysis or clustering** is the task of grouping a set of objects in such a way that objects in the same group (called a cluster) are more similar (in some sense) to each other than to those in other groups (clusters). It is a main task of exploratory data mining, and a common technique for statistical data analysis, used in many fields, including pattern recognition, image analysis, information retrieval, bioinformatics, data compression, computer graphics and machine learning.

    
**For a better understanding and more information, please refer to [SOURCE 1](https://en.wikipedia.org/wiki/Cluster_analysis) and [SOURCE 2](https://realpython.com/k-means-clustering-python/)**

### Does Cluster make sense for our data?

&emsp; 1. Does our data already have a potential class label?

&emsp; Using the existing class label in our data is often better than trying to create a new label for your data from clustering. If we have the option, supervised machine learning almost always outperforms unsupervised learning in classification tasks. If we have data but have no way to organize the data into meaningful groups, then clustering makes sense. But if we already have an intuitive class label in your data set, then the labels created by a clustering analysis may not perform as well as the original class label.

&emsp; 2. Is our data categorical or continuous?

&emsp; Many clustering algorithms (like DBSCAN or K-Means) use a distance measurement to calculate the similarity between observations. Because of this, certain clustering algorithms will perform better with continuous attributes. However, if we have categorical data, you can one-hot encode the attributes or use a clustering algorithm built for categorical data, such as K-Modes. It should be noted that it does not make a lot of sense to calculate distance between binary variables. Knowing how different clustering algorithms perform on different data types is essential for deciding if clustering makes sense for our data. 

&emsp; 3. What does our data look like?

&emsp; A simple visualization of your data with a scatter plot can provide insights into whether your data is well suited for clustering. If visualization reveals that our data has no amount of separation or distinct groups, then clustering may not be appropriate.

&emsp; 4. Do we have a way to validate our clustering algorithm?

&emsp; In order to trust the clustering algorithm results, we must have a method for measuring the algorithm's performance. Clustering algorithm performance can be validated with either internal or external validation metrics.

  - An example of **internal validation is the silhouette score**, a way to measure how well each observation is clustered (1.0 is perfect, 0.0 is worst). 

  - An example of **external validation** is when the class label for a data set is already known, but we want to test how well a particular clustering algorithm performs on predicting the existing classes. A noteworthy caveat to the external validation approach is that there is not a huge use case for clustering if the data already has class labels! To have confidence in our machine learning model, we must have a consistent metric for measuring model performance. Clustering is no different. We must have a way to quantitatively assess how well the model is clustering the data. 
  - Before conducting a clustering analysis, we consider which type of validation and which metric makes the most sense for our data. Some algorithms may perform deceivingly well with certain validation metrics, so we may need to use a combination of performance metrics to negate this issue. If we consistently achieve poor model performance, then clustering is not a good fit for your data.
   
&emsp; 5. Does clustering provide any new insight into the data?

&emsp; Letâ€™s say that we meet all the above considerations: 
   - We have continuous data with no class label
   - We visualize the data and there is some separation
   - We choose a validation metric that makes sense for our analysis
   - We run a clustering algorithm on the data and obtain a reasonably high silhouette score

our work is not done. After performing a clustering analysis, it is crucial to examine the observations in the individual clusters. This step allows us to assess whether or not the clusters provide any new insight into the data. Did the algorithm really find similar groups of observations and maximize intraclass similarity while minimizing between cluster similarity? An easy way to examine clusters is to calculate simple statistics for the observations in each cluster, such as the mean. If clustering fails to produce any new or useful insights into our data, then our data is not well suited for clustering.

[Click here for more on 'When Clustering Doesnâ€™t Make Sense'.](https://towardsdatascience.com/when-clustering-doesnt-make-sense-c6ed9a89e9e6)

### The Elbow Method

**- "Elbow Method"** can be used to find the optimum number of clusters in cluster analysis. The elbow method is used to determine the optimal number of clusters in k-means clustering. The elbow method plots the value of the cost function produced by different values of k. If k increases, average distortion will decrease, each cluster will have fewer constituent instances, and the instances will be closer to their respective centroids. However, the improvements in average distortion will decline as k increases. The value of k at which improvement in distortion declines the most is called the elbow, at which we should stop dividing the data into further clusters.


**For a better understanding and more information, please refer to [The Elbow Method SOURCE 1](https://en.wikipedia.org/wiki/Elbow_method_(clustering)), [The Elbow Method SOURCE 2](https://medium.com/@mudgalvivek2911/machine-learning-clustering-elbow-method-4e8c2b404a5d) and [KMeans SOURCE 1](https://towardsdatascience.com/understanding-k-means-clustering-in-machine-learning-6a6e67336aa1)**    

**Let's find out the groups of employees who left. You can observe that the most important factor for any employee to stay or leave is satisfaction and performance in the company. So let's bunch them in the group of people using cluster analysis.**
"""

from pyclustertend import hopkins

hopkins(df1_scaled, df1.shape[0])

#First : Get the Best KMeans 
ks = range(1,10)
inertias=[]
for k in ks :
    # Create a KMeans clusters
    kc = KMeans(n_clusters=k,random_state=1)
    kc.fit(df1_scaled)
    inertias.append(kc.inertia_)

# Plot ks vs inertias
f, ax = plt.subplots(figsize=(8, 6))
plt.plot(ks, inertias, '-o')
plt.xlabel('Number of clusters, k')
plt.ylabel('Inertia')
plt.xticks(ks)
plt.style.use('ggplot')
plt.title('What is the Best Number for KMeans ?')
plt.show()

from yellowbrick.cluster import KElbowVisualizer

kmeans = KMeans()
visu = KElbowVisualizer(kmeans, k = (1,10))
visu.fit(df1_scaled)
visu.show();

from sklearn.metrics import silhouette_samples,silhouette_score

ssd =[]

K = range(2, 10)

for k in K:
    model = KMeans(n_clusters=k)
    model.fit(df1_scaled)
    ssd.append(model.inertia_)
    print(f'Silhouette Score for {k} clusters: {silhouette_score(df1_scaled, model.labels_)}')

from sklearn.cluster import KMeans

from yellowbrick.cluster import SilhouetteVisualizer

model_4 = KMeans(n_clusters=4, random_state=101)
visualizer = SilhouetteVisualizer(model_4)
visualizer.fit(df1_scaled)    # Fit the data to the visualizer
visualizer.poof();

from sklearn.cluster import KMeans

from yellowbrick.cluster import SilhouetteVisualizer

model_3 = KMeans(n_clusters=3, random_state=101)
visualizer = SilhouetteVisualizer(model_3)
visualizer.fit(df1_scaled)    # Fit the data to the visualizer
visualizer.poof();

k_means_model = KMeans(n_clusters = 3, random_state = 101)
k_means_model.fit_predict(df1_scaled)
labels = k_means_model.labels_
labels

df['predicted_clusters'] = labels
df

df['predicted_clusters'].value_counts()

fig = px.pie(df, values = df['predicted_clusters'].value_counts(), 
             names = (df['predicted_clusters'].value_counts()).index, 
             title = 'Predicted_Clusters Distribution')
fig.show()

fig = px.pie(df, values = df[df['left']==0]['predicted_clusters'].value_counts(), 
             names = df[df['left']==0]['predicted_clusters'].value_counts().index, 
             title = 'Predicted_Clusters_Almost_Lost Distribution')
fig.show()

fig = px.pie(df, values = df[df['left']==1]['predicted_clusters'].value_counts(), 
             names = df[df['left']==1]['predicted_clusters'].value_counts().index, 
             title = 'Predicted_Clusters_Almost_Lost Distribution')
fig.show()

pd.crosstab(df['left'], 
            df['predicted_clusters']).iplot(kind="bar", title = 'Compare (left vs predicted-clusters)',
            xTitle = 'left & clusters', yTitle = 'counts')

df.groupby('left').mean()

# cprint('Dataset describe results according to the "left==1" condition','green')

df.groupby(['left', 'predicted_clusters']).mean()

pd.crosstab(df['predicted_clusters'], 
            df['left']).iplot(kind="bar", title = 'Compare (predicted-clusters vs left)',
            xTitle = 'clusters & left', yTitle = 'counts')

df.left.value_counts()

# cprint('Dataset describe results according to the "left==1" condition','green')

df.groupby('predicted_clusters').mean()

# cprint('Dataset describe results according to the "left==1" condition','green')

df.groupby(['predicted_clusters', 'left']).mean()

"""<a id="8"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">8) MODEL BUILDING<p>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

**- Split Data as Train and Test set**<br>
**- Built Gradient Boosting Classifier, Evaluate Model Performance and Predict Test Data**<br>
**- Built K Neighbors Classifier and Evaluate Model Performance and Predict Test Data**<br>
**- Built Random Forest Classifier and Evaluate Model Performance and Predict Test Data**<br>
---------

### Evaluating Model Performance

**- Confusion Matrix:** You can use scikit-learn metrics module for accuracy calculation. A Confusion matrix is an N x N matrix used for evaluating the performance of a classification model, where N is the number of target classes. The matrix compares the actual target values with those predicted by the machine learning model. This gives us a holistic view of how well our classification model is performing and what kinds of errors it is making.

**For a better understanding and more information, please refer to [Confusion Matrix](https://www.analyticsvidhya.com/blog/2020/04/confusion-matrix-machine-learning/)**

**- Yellowbrick:** Yellowbrick is a suite of visualization and diagnostic tools that will enable quicker model selection. Itâ€™s a Python package that combines scikit-learn and matplotlib. Some of the more popular visualization tools include model selection, feature visualization, classification and regression visualization

**For a better understanding and more information, please refer to [Yellowbrick](https://www.analyticsvidhya.com/blog/2018/05/yellowbrick-a-set-of-visualization-tools-to-accelerate-your-model-selection-process/)**

**Here, Dataset is broken into two parts in ratio of 70:30. It means 70% data will used for model training and 30% for model testing.**
"""

df2 = df.drop('predicted_clusters', axis = 1)
df2.head(1)

df2 = pd.get_dummies(df2, columns = ['department','salary'], drop_first = True)
df2.head(1)

"""<a id="8.1"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.1 - Spliting Data as Train & Test<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>
"""

X = df2.drop('left', axis = 1)
y = df2['left']

X_train, X_test, y_train, y_test = train_test_split(X, y, stratify = y, test_size = 0.3, random_state = 101)

scaler = MinMaxScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

def eval(model, X_train, X_test):
    y_pred = model.predict(X_test)
    y_pred_train = model.predict(X_train)
    
    print(confusion_matrix(y_test, y_pred))
    print("Test_Set")
    print(classification_report(y_test,y_pred))
    print("Train_Set")
    print(classification_report(y_train,y_pred_train))
    plot_confusion_matrix(model, X_test, y_test, cmap="plasma")

def train_val(y_train, y_train_pred, y_test, y_pred):
    
    scores = {"train_set": {"Accuracy" : accuracy_score(y_train, y_train_pred),
                            "Precision" : precision_score(y_train, y_train_pred),
                            "Recall" : recall_score(y_train, y_train_pred),                          
                            "f1" : f1_score(y_train, y_train_pred)},
    
              "test_set": {"Accuracy" : accuracy_score(y_test, y_pred),
                           "Precision" : precision_score(y_test, y_pred),
                           "Recall" : recall_score(y_test, y_pred),                          
                           "f1" : f1_score(y_test, y_pred)}}
    
    return pd.DataFrame(scores)

"""<a id="8.2"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.2 - Best Model Scores With PyCaret<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

**PyCaret** is an open source low-code machine learning library in Python that aims to reduce the hypothesis to insights cycle time in a ML experiment. It enables data scientists to perform end-to-end experiments quickly and efficiently. In comparison with the other open source machine learning libraries, PyCaret is an alternate low-code library that can be used to perform complex machine learning tasks with only few lines of code. PyCaret is simple and easy to use. All the operations performed in PyCaret are automatically stored in a custom Pipeline that is fully orchestrated for deployment. PyCaret is essentially a Python wrapper around several machine learning libraries and frameworks such as scikit-learn, XGBoost, Microsoft LightGBM, spaCy and many more.
    
**For a better understanding and more information, please refer to [SOURCE 1](https://pycaret.org/about/), [SOURCE 2](https://machinelearningmastery.com/pycaret-for-machine-learning/), [SOURCE 3](https://www.analyticsvidhya.com/blog/2020/05/pycaret-machine-learning-model-seconds/), [SOURCE 1](https://pycaret.org/about/) & [SOURCE 4](https://towardsdatascience.com/every-data-scientist-should-use-pycaret-45a1e8e984be)**
"""

from pycaret.classification import *

employee_clf = setup(df2, target = 'left', 
                     session_id = 123, 
                     train_size=0.8, 
                     log_experiment=True, 
                     log_plots=True, 
                     experiment_name = 'employee_churn_model')

best_model_scores = compare_models()

"""<a id="8.3"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.3 - Gradient Boosting Classifier<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

<a id="8.3.1"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.3.1 Model Building</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

GB_model = GradientBoostingClassifier(random_state = 101)
GB_model.fit(X_train, y_train)
y_pred = GB_model.predict(X_test)
y_train_pred = GB_model.predict(X_train)

GB_model_f1 = f1_score(y_test, y_pred)
GB_model_acc = accuracy_score(y_test, y_pred)
GB_model_recall = recall_score(y_test, y_pred)
GB_model_auc = roc_auc_score(y_test, y_pred)

"""<a id="8.3.2"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.3.2 Evaluating Model Performance</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

print("GB_Model")
print ("------------------")
eval(GB_model, X_train, X_test)

cf_matrix = confusion_matrix(y_test, y_pred)

group_names = ["True Negatives (TN)", "False Positives (FP)\n(Type I Error)", "False Negatives (FN)\n(Type II Error)", "True Positives (TP)"]

group_counts = ["{0:0.0f}".format(value) for value in
                cf_matrix.flatten()]

group_percentages = ["{0:.2%}".format(value) for value in
                     cf_matrix.flatten()/np.sum(cf_matrix)]

labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names, group_counts, group_percentages)]

labels = np.asarray(labels).reshape(2, 2)

ax = sns.heatmap(cf_matrix, annot=labels, fmt="", cmap="Blues")
ax.set(xlabel="Predicted Class", ylabel = "Actual Claass");

plt.figure(figsize=(12, 8))
visualizer = ClassificationReport(GB_model, support=True)
visualizer.fit(X_train, y_train)        # Fit the visualizer and the model
visualizer.score(X_test, y_test)        # Evaluate the model on the test data
visualizer.show()

train_val(y_train, y_train_pred, y_test, y_pred)

from yellowbrick.classifier import ClassPredictionError

visualizer = ClassPredictionError(GB_model)

# Fit the training data to the visualizer
visualizer.fit(X_train, y_train)

# Evaluate the model on the test data
visualizer.score(X_test, y_test)

# Draw visualization
visualizer.poof();

"""<a id="8.3.3"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.3.3 Feature Importance for Gradient Boosting Model</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

GB_feature_imp = pd.DataFrame(index=X.columns, data = GB_model.feature_importances_, columns = ['Importance']).sort_values("Importance", ascending = False)
GB_feature_imp

plt.figure(figsize = (12,6))
sns.barplot(data = GB_feature_imp.sort_values('Importance', ascending = False), x = GB_feature_imp.sort_values('Importance', ascending = False).index, y = 'Importance')
plt.xticks(rotation = 75);

"""<a id="8.3.4"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.3.4 Gradient Boosting Classifier Cross Validation</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

GB_cv = GradientBoostingClassifier(random_state = 101)

GB_cv_scores = cross_validate(GB_cv, X_train, y_train, 
                              scoring = ['accuracy', 'precision','recall', 'f1', 'roc_auc'], cv = 10)
GB_cv_scores = pd.DataFrame(GB_cv_scores, index = range(1, 11))

GB_cv_scores.mean()[2:]

"""<a id="8.3.5"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.3.5 Gradient Boosting Classifier GridSearchCV</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

param_grid = {"n_estimators":[100, 200, 300],
              "subsample":[0.5, 1], 
              "max_features" : [None, 2, 3, 4],
              "learning_rate": [0.001, 0.01, 0.1], 
              'max_depth':[3, 4, 5, 6]}

GB_grid = GradientBoostingClassifier(random_state = 101)
GB_grid_model = GridSearchCV(GB_grid, param_grid, scoring = "f1", verbose = 0, n_jobs = -1).fit(X_train, y_train)

GB_grid_model.best_estimator_

print(colored('\033[1mBest Parameters of GridSearchCV for Gradient Boosting Model:\033[0m', 'blue'), colored(GB_grid_model.best_params_, 'cyan'))
print("--------------------------------------------------------------------------------------------------------------------")
print(colored('\033[1mBest Estimator of GridSearchCV for Gradient Boosting Model:\033[0m', 'blue'), colored(GB_grid_model.best_estimator_, 'cyan'))

GB_tuned = GradientBoostingClassifier(learning_rate = 0.01,
                                      max_depth = 6, 
                                      n_estimators = 200,
                                      subsample = 0.5,
                                      random_state = 101).fit(X_train, y_train)

y_pred = GB_tuned.predict(X_test)
y_train_pred = GB_tuned.predict(X_train)

GB_tuned_f1 = f1_score(y_test, y_pred)
GB_tuned_acc = accuracy_score(y_test, y_pred)
GB_tuned_recall = recall_score(y_test, y_pred)
GB_tuned_auc = roc_auc_score(y_test, y_pred)

print("GB_tuned")
print ("------------------")
eval(GB_tuned, X_train, X_test)

cf_matrix = confusion_matrix(y_test, y_pred)

group_names = ["True Negatives (TN)", "False Positives (FP)\n(Type I Error)", "False Negatives (FN)\n(Type II Error)", "True Positives (TP)"]

group_counts = ["{0:0.0f}".format(value) for value in
                cf_matrix.flatten()]

group_percentages = ["{0:.2%}".format(value) for value in
                     cf_matrix.flatten()/np.sum(cf_matrix)]

labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names, group_counts, group_percentages)]

labels = np.asarray(labels).reshape(2, 2)

ax = sns.heatmap(cf_matrix, annot=labels, fmt="", cmap="Blues")
ax.set(xlabel="Predicted Class", ylabel = "Actual Claass");

plt.figure(figsize=(12, 8))
visualizer = ClassificationReport(GB_tuned, support=True)
visualizer.fit(X_train, y_train)        # Fit the visualizer and the model
visualizer.score(X_test, y_test)        # Evaluate the model on the test data
visualizer.show()

train_val(y_train, y_train_pred, y_test, y_pred)

from yellowbrick.classifier import ClassPredictionError

visualizer = ClassPredictionError(GB_tuned)

# Fit the training data to the visualizer
visualizer.fit(X_train, y_train)

# Evaluate the model on the test data
visualizer.score(X_test, y_test)

# Draw visualization
visualizer.poof();

"""<a id="8.3.6"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.3.6 Gradient Boosting Classifier ROC (Receiver Operating Curve) & AUC (Area Under Curve)</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

plot_roc_curve(GB_model, X_test, y_test);

plot_precision_recall_curve(GB_model, X_test, y_test);

"""<a id="8.3.7"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.3.7 Prediction</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

GB_Pred = {"Actual": y_test, "GB_Pred":y_pred}
GB_Pred = pd.DataFrame.from_dict(GB_Pred)
GB_Pred.head(20)

Model_Preds = GB_Pred
Model_Preds.head(1)

"""<a id="8.4"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.4 - KNeighbors Classifier<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

<a id="8.4.1"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.4.1 Model Building</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

KNN_model = KNeighborsClassifier(n_neighbors = 5)
KNN_model.fit(X_train, y_train)
y_pred = KNN_model.predict(X_test)
y_train_pred = KNN_model.predict(X_train)

KNN_model_f1 = f1_score(y_test, y_pred)
KNN_model_acc = accuracy_score(y_test, y_pred)
KNN_model_recall = recall_score(y_test, y_pred)
KNN_model_auc = roc_auc_score(y_test, y_pred)

"""<a id="8.4.2"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.4.2 Evaluating Model Performance</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

print("KNN_Model")
print ("------------------")
eval(KNN_model, X_train, X_test)

cf_matrix = confusion_matrix(y_test, y_pred)

group_names = ["True Negatives (TN)", "False Positives (FP)\n(Type I Error)", "False Negatives (FN)\n(Type II Error)", "True Positives (TP)"]

group_counts = ["{0:0.0f}".format(value) for value in
                cf_matrix.flatten()]

group_percentages = ["{0:.2%}".format(value) for value in
                     cf_matrix.flatten()/np.sum(cf_matrix)]

labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names, group_counts, group_percentages)]

labels = np.asarray(labels).reshape(2, 2)

ax = sns.heatmap(cf_matrix, annot=labels, fmt="", cmap="Blues")
ax.set(xlabel="Predicted Class", ylabel = "Actual Claass");

plt.figure(figsize=(12, 8))
visualizer = ClassificationReport(KNN_model, support=True)
visualizer.fit(X_train, y_train)        # Fit the visualizer and the model
visualizer.score(X_test, y_test)        # Evaluate the model on the test data
visualizer.show()

train_val(y_train, y_train_pred, y_test, y_pred)

from yellowbrick.classifier import ClassPredictionError

visualizer = ClassPredictionError(KNN_model)

# Fit the training data to the visualizer
visualizer.fit(X_train, y_train)

# Evaluate the model on the test data
visualizer.score(X_test, y_test)

# Draw visualization
visualizer.poof();

"""<a id="8.4.3"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.4.3 KNeighbors Classifier Cross Validation</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

KNN_cv = KNeighborsClassifier(n_neighbors = 5)

KNN_cv_scores = cross_validate(KNN_cv, X_train, y_train, 
                              scoring = ['accuracy', 'precision','recall', 'f1', 'roc_auc'], cv = 10)
KNN_cv_scores = pd.DataFrame(KNN_cv_scores, index = range(1, 11))

KNN_cv_scores.mean()[2:]

"""<a id="8.4.4"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.4.4 Elbow Method for Choosing Reasonable K Values</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

test_error_rates = []

for k in range(1, 30):
    KNN = KNeighborsClassifier(n_neighbors = k)
    KNN.fit(X_train, y_train) 
   
    y_pred = KNN.predict(X_test)
    
    test_error = 1 - accuracy_score(y_test, y_pred)
    test_error_rates.append(test_error)
    
print(test_error_rates)

plt.figure(figsize = (15, 8))
plt.plot(range(1, 30), test_error_rates, color = 'blue', linestyle = '--', marker = 'o',
         markerfacecolor = 'red', markersize = 10)
plt.title('Error Rate vs. K Value')
plt.xlabel('K_values')
plt.ylabel('Error Rate')

plt.hlines(y = 0.04307948860478039, xmin = 0, xmax = 30, colors = 'r', linestyles = "--", label = "K-Value = 2 Line")
plt.hlines(y = 0.04558087826570312, xmin = 0, xmax = 30, colors = 'r', linestyles = "--", label = "K-Value = 4 Line")
plt.hlines(y = 0.055864369093941, xmin = 0, xmax = 30, colors = 'blue', linestyles = "--", label = "Default K-Value = 5 Line")
plt.legend(prop = {"size":14});

# FIRST A QUICK COMPARISON TO OUR DEFAULT K=5

knn5 = KNeighborsClassifier(n_neighbors = 5)

knn5.fit(X_train,y_train)
pred = knn5.predict(X_test)

print('WITH K=5')
print('---------------')
print(confusion_matrix(y_test, pred))
print('---------------')
print(classification_report(y_test, pred))

# NOW K=2

knn2 = KNeighborsClassifier(n_neighbors = 2)

knn2.fit(X_train,y_train)
pred = knn2.predict(X_test)

print('WITH K=2')
print('---------------')
print(confusion_matrix(y_test, pred))
print('---------------')
print(classification_report(y_test, pred))

# NOW K=4

knn4 = KNeighborsClassifier(n_neighbors = 4)

knn4.fit(X_train,y_train)
pred = knn4.predict(X_test)

print('WITH K=4')
print('---------------')
print(confusion_matrix(y_test, pred))
print('---------------')
print(classification_report(y_test, pred))

# NOW K=6

knn6 = KNeighborsClassifier(n_neighbors = 6)

knn6.fit(X_train,y_train)
pred = knn6.predict(X_test)

print('WITH K=6')
print('---------------')
print(confusion_matrix(y_test, pred))
print('---------------')
print(classification_report(y_test, pred))

# NOW K=8

knn8 = KNeighborsClassifier(n_neighbors = 8)

knn8.fit(X_train,y_train)
pred = knn8.predict(X_test)

print('WITH K=8')
print('---------------')
print(confusion_matrix(y_test, pred))
print('---------------')
print(classification_report(y_test, pred))

# NOW K=10

knn10 = KNeighborsClassifier(n_neighbors = 10)

knn10.fit(X_train,y_train)
pred = knn10.predict(X_test)

print('WITH K=10')
print('---------------')
print(confusion_matrix(y_test, pred))
print('---------------')
print(classification_report(y_test, pred))

"""<a id="8.4.5"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.4.5 KNeighbors Classifier GridsearchCV for Choosing Reasonable K Values</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

k_values = range(1, 30)
param_grid = {"n_neighbors": k_values, "p": [1, 2], "weights": ['uniform', "distance"]}

KNN_grid = KNeighborsClassifier()
KNN_grid_model = GridSearchCV(KNN_grid, param_grid, cv = 10, scoring = 'recall')  
KNN_grid_model.fit(X_train, y_train)

KNN_grid_model.best_estimator_

print(colored('\033[1mBest Parameters of GridSearchCV for KNN Model:\033[0m', 'blue'), colored(KNN_grid_model.best_params_, 'cyan'))
print("--------------------------------------------------------------------------------------------------------------------")
print(colored('\033[1mBest Estimator of GridSearchCV for KNN Model:\033[0m', 'blue'), colored(KNN_grid_model.best_estimator_, 'cyan'))

# NOW WITH K=3

KNN_tuned3 = KNeighborsClassifier(n_neighbors = 3, p = 1)
KNN_tuned3.fit(X_train, y_train)
y_pred = KNN_tuned3.predict(X_test)
y_train_pred = KNN_tuned3.predict(X_train)

KNN_tuned3_f1 = f1_score(y_test, y_pred)
KNN_tuned3_acc = accuracy_score(y_test, y_pred)
KNN_tuned3_recall = recall_score(y_test, y_pred)
KNN_tuned3_auc = roc_auc_score(y_test, y_pred)

print("KNN_tuned (K=3)")
print ("------------------")
eval(KNN_tuned3, X_train, X_test)
train_val(y_train, y_train_pred, y_test, y_pred)

# NOW WITH K=1

KNN_tuned1 = KNeighborsClassifier(n_neighbors = 1, p = 1)
KNN_tuned1.fit(X_train, y_train)
y_pred = KNN_tuned1.predict(X_test)
y_train_pred = KNN_tuned1.predict(X_train)

KNN_tuned1_f1 = f1_score(y_test, y_pred)
KNN_tuned1_acc = accuracy_score(y_test, y_pred)
KNN_tuned1_recall = recall_score(y_test, y_pred)
KNN_tuned1_auc = roc_auc_score(y_test, y_pred)

print("KNN_tuned (K=1)")
print ("------------------")
eval(KNN_tuned1, X_train, X_test)

"""<a id="8.4.6"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.4.6 KNeighbors Classifier ROC (Receiver Operating Curve) and AUC (Area Under Curve)</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

plot_roc_curve(KNN_model, X_test, y_test);

plot_precision_recall_curve(KNN_model, X_test, y_test);

"""<a id="8.4.7"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.4.7 Prediction</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

KNN_Pred = {"Actual": y_test, "KNN_Pred":y_pred}
KNN_Pred = pd.DataFrame.from_dict(KNN_Pred)
KNN_Pred.head(20)

KNN_Pred.drop("Actual", axis = 1, inplace = True)
Model_Preds = pd.merge(Model_Preds, KNN_Pred, left_index = True, right_index = True)
Model_Preds.head(20)

"""<a id="8.5"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.5 - Random Forest Classifier<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

<a id="8.5.1"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.5.1 Model Building</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

RF_model = RandomForestClassifier(class_weight = "balanced", random_state = 101)
RF_model.fit(X_train, y_train)
y_pred = RF_model.predict(X_test)
y_train_pred = RF_model.predict(X_train)

RF_model_f1 = f1_score(y_test, y_pred)
RF_model_acc = accuracy_score(y_test, y_pred)
RF_model_recall = recall_score(y_test, y_pred)
RF_model_auc = roc_auc_score(y_test, y_pred)

"""<a id="8.5.2"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.5.2 Evaluating Model Performance</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

print("RF_Model")
print ("------------------")
eval(RF_model, X_train, X_test)

cf_matrix = confusion_matrix(y_test, y_pred)

group_names = ["True Negatives (TN)", "False Positives (FP)\n(Type I Error)", "False Negatives (FN)\n(Type II Error)", "True Positives (TP)"]

group_counts = ["{0:0.0f}".format(value) for value in
                cf_matrix.flatten()]

group_percentages = ["{0:.2%}".format(value) for value in
                     cf_matrix.flatten()/np.sum(cf_matrix)]

labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names, group_counts, group_percentages)]

labels = np.asarray(labels).reshape(2, 2)

ax = sns.heatmap(cf_matrix, annot=labels, fmt="", cmap="Blues")
ax.set(xlabel="Predicted Class", ylabel = "Actual Claass");

plt.figure(figsize=(12, 8))
visualizer = ClassificationReport(RF_model, support=True)
visualizer.fit(X_train, y_train)        # Fit the visualizer and the model
visualizer.score(X_test, y_test)        # Evaluate the model on the test data
visualizer.show()

train_val(y_train, y_train_pred, y_test, y_pred)

from yellowbrick.classifier import ClassPredictionError

visualizer = ClassPredictionError(RF_model)

# Fit the training data to the visualizer
visualizer.fit(X_train, y_train)

# Evaluate the model on the test data
visualizer.score(X_test, y_test)

# Draw visualization
visualizer.poof();

"""<a id="8.5.3"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.5.3 Feature Importance for Random Forest Model</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

RF_feature_imp = pd.DataFrame(index=X.columns, data = RF_model.feature_importances_, columns = ['Importance']).sort_values("Importance", ascending = False)
RF_feature_imp

plt.figure(figsize = (12,6))
sns.barplot(data = RF_feature_imp.sort_values('Importance', ascending = False), x = RF_feature_imp.sort_values('Importance', ascending = False).index, y = 'Importance')
plt.xticks(rotation = 75);

"""<a id="8.5.4"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.5.4 Random Forest Classifier Cross Validation</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

RF_cv = RandomForestClassifier(class_weight = "balanced", random_state = 101)

RF_cv_scores = cross_validate(RF_cv, X_train, y_train, 
                              scoring = ['accuracy', 'precision','recall', 'f1', 'roc_auc'], cv = 10)
RF_cv_scores = pd.DataFrame(RF_cv_scores, index = range(1, 11))

RF_cv_scores.mean()[2:]

"""<a id="8.5.5"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.5.5 Random Forest Classifier GridSearchCV</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

param_grid = {'n_estimators' : [50, 100, 300],
             'max_features' : [2, 3, 4],
             'max_depth' : [3, 5, 7, 9],
             'min_samples_split' : [2, 5, 8]}

RF_grid = RandomForestClassifier(class_weight = 'balanced', random_state = 101)
RF_grid_model = GridSearchCV(estimator = RF_grid, 
                             param_grid = param_grid, 
                             scoring = "recall", 
                             n_jobs = -1, verbose = 0)
RF_grid_model.fit(X_train, y_train)

RF_grid_model.best_estimator_

print(colored('\033[1mBest Parameters of GridSearchCV for Random Forest Model:\033[0m', 'blue'), colored(RF_grid_model.best_params_, 'cyan'))
print("--------------------------------------------------------------------------------------------------------------------")
print(colored('\033[1mBest Estimator of GridSearchCV for Random Forest Model:\033[0m', 'blue'), colored(RF_grid_model.best_estimator_, 'cyan'))

RF_tuned = RandomForestClassifier(class_weight = 'balanced',
                                  max_depth = 3,
                                  max_features = 4,
                                  n_estimators = 300,
                                  random_state = 101).fit(X_train, y_train)

y_pred = RF_tuned.predict(X_test)
y_train_pred = RF_tuned.predict(X_train)

RF_tuned_f1 = f1_score(y_test, y_pred)
RF_tuned_acc = accuracy_score(y_test, y_pred)
RF_tuned_recall = recall_score(y_test, y_pred)
RF_tuned_auc = roc_auc_score(y_test, y_pred)

print("RF_tuned")
print ("------------------")
eval(RF_tuned, X_train, X_test)

cf_matrix = confusion_matrix(y_test, y_pred)

group_names = ["True Negatives (TN)", "False Positives (FP)\n(Type I Error)", "False Negatives (FN)\n(Type II Error)", "True Positives (TP)"]

group_counts = ["{0:0.0f}".format(value) for value in
                cf_matrix.flatten()]

group_percentages = ["{0:.2%}".format(value) for value in
                     cf_matrix.flatten()/np.sum(cf_matrix)]

labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names, group_counts, group_percentages)]

labels = np.asarray(labels).reshape(2, 2)

ax = sns.heatmap(cf_matrix, annot=labels, fmt="", cmap="Blues")
ax.set(xlabel="Predicted Class", ylabel = "Actual Claass");

plt.figure(figsize=(12, 8))
visualizer = ClassificationReport(RF_tuned, support=True)
visualizer.fit(X_train, y_train)        # Fit the visualizer and the model
visualizer.score(X_test, y_test)        # Evaluate the model on the test data
visualizer.show()

train_val(y_train, y_train_pred, y_test, y_pred)

from yellowbrick.classifier import ClassPredictionError

visualizer = ClassPredictionError(RF_tuned)

# Fit the training data to the visualizer
visualizer.fit(X_train, y_train)

# Evaluate the model on the test data
visualizer.score(X_test, y_test)

# Draw visualization
visualizer.poof();

"""<a id="8.5.6"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.5.6 Random Forest Classifier ROC (Receiver Operating Curve) and AUC (Area Under Curve)</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

plot_roc_curve(RF_model, X_test, y_test);

plot_precision_recall_curve(RF_model, X_test, y_test);

"""<a id="8.5.7"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.5.7 Prediction</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

RF_Pred = {"Actual": y_test, "RF_Pred":y_pred}
RF_Pred = pd.DataFrame.from_dict(RF_Pred)
RF_Pred.head(20)

RF_Pred.drop("Actual", axis = 1, inplace = True)
Model_Preds = pd.merge(Model_Preds, RF_Pred, left_index = True, right_index = True)
Model_Preds.head(20)

Model_Preds.sample(10)

"""<a id="8.6"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.6 - CatBoost Classifier<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

<a id="8.6.1"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.6.1 Model Building</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

from catboost import CatBoostClassifier

CB_model = CatBoostClassifier(verbose = False, scale_pos_weight = 4, random_state = 101)
CB_model.fit(X_train, y_train)
y_pred = CB_model.predict(X_test)
y_train_pred = CB_model.predict(X_train)

CB_model_f1 = f1_score(y_test, y_pred)
CB_model_acc = accuracy_score(y_test, y_pred)
CB_model_recall = recall_score(y_test, y_pred)
CB_model_auc = roc_auc_score(y_test, y_pred)

"""<a id="8.6.2"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.6.2 Evaluating Model Performance</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

print("CB_Model")
print ("------------------")
eval(CB_model, X_train, X_test)

cf_matrix = confusion_matrix(y_test, y_pred)

group_names = ["True Negatives (TN)", "False Positives (FP)\n(Type I Error)", "False Negatives (FN)\n(Type II Error)", "True Positives (TP)"]

group_counts = ["{0:0.0f}".format(value) for value in
                cf_matrix.flatten()]

group_percentages = ["{0:.2%}".format(value) for value in
                     cf_matrix.flatten()/np.sum(cf_matrix)]

labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names, group_counts, group_percentages)]

labels = np.asarray(labels).reshape(2, 2)

ax = sns.heatmap(cf_matrix, annot=labels, fmt="", cmap="Blues")
ax.set(xlabel="Predicted Class", ylabel = "Actual Claass");

train_val(y_train, y_train_pred, y_test, y_pred)

"""<a id="8.6.3"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.6.3 Feature Importance for CatBoost Model</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

CB_feature_imp = pd.DataFrame(index = X.columns, data = CB_model.feature_importances_, columns = ['Importance']).sort_values("Importance", ascending = False)
CB_feature_imp

plt.figure(figsize = (12, 6))
sns.barplot(data = CB_feature_imp.sort_values('Importance', ascending = False), x = CB_feature_imp.sort_values('Importance', ascending = False).index, y = 'Importance')
plt.xticks(rotation = 75);

"""<a id="8.6.4"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.6.4 CatBoost Classifier Cross Validation</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

CB_cv = CatBoostClassifier(verbose = False, scale_pos_weight = 4, random_state = 101)

CB_cv_scores = cross_validate(CB_cv, X_train, y_train, 
                              scoring = ['accuracy', 'precision','recall', 'f1', 'roc_auc'], cv = 10)
CB_cv_scores = pd.DataFrame(CB_cv_scores, index = range(1, 11))

CB_cv_scores.mean()[2:]

CB_cm = confusion_matrix(y_test, y_pred)
CB_cm

CB_cm_df = pd.DataFrame(CB_cm)
CB_cm_df

CB_cm_df = CB_cm_df.rename(columns={0:"Employee_Stayed", 1:"Employe_Left"}, index={0:"Employee_Stayed", 1:"Employe_Left"})
CB_cm_df

CB_cm_df["Total"] = CB_cm_df["Employee_Stayed"] + CB_cm_df["Employe_Left"]
CB_cm_df

fig = px.bar(CB_cm_df, x="Employee_Stayed", y="Total", color="Employe_Left", title="CatBoost Confusion Matrix Distribution")

fig.update_layout(
    xaxis_title="Employees-Left                      Employees_Stayed",
    yaxis_title="The Number of Employees",
    font=dict(
        family="Courier New, monospace",
        size=14,
        color="#7f7f7f"
    )
)

fig.show()

"""<a id="8.6.5"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.6.5 CatBoost Classifier GridSearchCV</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

param_grid = {'learning_rate': [0.01, 0.03, 0.1, 0.5],
              'depth': [4, 6, 8, 10],
              'l2_leaf_reg': [1, 3, 5, 7, 9]}

CB_grid = CatBoostClassifier(verbose = False, scale_pos_weight = 4, random_state = 101)
CB_grid_model = GridSearchCV(estimator = CB_grid, 
                             param_grid = param_grid, 
                             scoring = "recall", 
                             n_jobs = -1, verbose = 0)
CB_grid_model.fit(X_train, y_train)

CB_grid_model.best_params_

print(colored('\033[1mBest Parameters of GridSearchCV for Random Forest Model:\033[0m', 'blue'), 
      colored(CB_grid_model.best_params_, 'cyan'))

CB_tuned = CatBoostClassifier(verbose = False, 
                              scale_pos_weight = 4,
                              depth = 4,
                              l2_leaf_reg = 3,
                              learning_rate = 0.01,
                              random_state = 101).fit(X_train, y_train)

y_pred = CB_tuned.predict(X_test)
y_train_pred = CB_tuned.predict(X_train)

CB_tuned_f1 = f1_score(y_test, y_pred)
CB_tuned_acc = accuracy_score(y_test, y_pred)
CB_tuned_recall = recall_score(y_test, y_pred)
CB_tuned_auc = roc_auc_score(y_test, y_pred)

print("CB_tuned")
print ("------------------")
eval(CB_tuned, X_train, X_test)

cf_matrix = confusion_matrix(y_test, y_pred)

group_names = ["True Negatives (TN)", "False Positives (FP)\n(Type I Error)", "False Negatives (FN)\n(Type II Error)", "True Positives (TP)"]

group_counts = ["{0:0.0f}".format(value) for value in
                cf_matrix.flatten()]

group_percentages = ["{0:.2%}".format(value) for value in
                     cf_matrix.flatten()/np.sum(cf_matrix)]

labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names, group_counts, group_percentages)]

labels = np.asarray(labels).reshape(2, 2)

ax = sns.heatmap(cf_matrix, annot=labels, fmt="", cmap="Blues")
ax.set(xlabel="Predicted Class", ylabel = "Actual Claass");

train_val(y_train, y_train_pred, y_test, y_pred)

CBtune_cm = confusion_matrix(y_test, y_pred)
CBtune_cm

CBtune_cm_df = pd.DataFrame(CBtune_cm)
CBtune_cm_df

CBtune_cm_df = CBtune_cm_df.rename(columns={0:"Employee_Stayed", 1:"Employe_Left"}, index={0:"Employee_Stayed", 1:"Employe_Left"})
CBtune_cm_df

CBtune_cm_df["Total"] = CBtune_cm_df["Employee_Stayed"] + CBtune_cm_df["Employe_Left"]
CBtune_cm_df

fig = px.bar(CBtune_cm_df, x="Employee_Stayed", y="Total", color="Employe_Left", title="CatBoost-Tuned Confusion Matrix Distribution")

fig.update_layout(
    xaxis_title="Employees-Left                      Employees_Stayed",
    yaxis_title="The Number of Employees",
    font=dict(
        family="Courier New, monospace",
        size=14,
        color="#7f7f7f"
    )
)

fig.show()

"""<a id="8.6.6"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.6.6 CatBoost Classifier ROC (Receiver Operating Curve) and AUC (Area Under Curve)</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

plot_roc_curve(CB_model, X_test, y_test);

plot_precision_recall_curve(CB_model, X_test, y_test);

"""<a id="8.6.7"></a>
#### <p style="background-color:#19D1D1; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">8.6.7 Prediction</p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#79FAF4" data-toggle="popover">Table of Contents</a>
"""

CB_Pred = {"Actual": y_test, "CB_Pred":y_pred}
CB_Pred = pd.DataFrame.from_dict(CB_Pred)
CB_Pred.head()

CB_Pred.drop("Actual", axis = 1, inplace = True)
Model_Preds = pd.merge(Model_Preds, CB_Pred, left_index = True, right_index = True)
Model_Preds.head()

Model_Preds.sample(10)

Model_Preds.loc[7347]

df2.loc[7347]

"""<a id="9"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">9) THE COMPARISON OF MODELS<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>
"""

compare = pd.DataFrame({"Model": ["GB_model", "GB_tuned", "KNN_Model", "KNN_tuned3", "RF_model", "RF_tuned", "CB_model", 
                                  "CB_tuned"],
                        
                        "F1_Score": [GB_model_f1, GB_tuned_f1, KNN_model_f1, KNN_tuned3_f1, RF_model_f1, RF_tuned_f1, 
                                     CB_model_f1, CB_tuned_f1],
                                                 
                        "Accuracy_Score": [GB_model_acc, GB_tuned_acc, KNN_model_acc, KNN_tuned3_acc, RF_model_acc, 
                                           RF_tuned_acc, CB_model_acc, CB_tuned_acc],
                        
                        "Recall_Score": [GB_model_recall, GB_tuned_recall, KNN_model_recall, KNN_tuned3_recall, RF_model_recall, 
                                     RF_tuned_recall, CB_model_recall, CB_tuned_recall],
                       
                        "ROC_AUC_Score": [GB_model_auc, GB_tuned_auc, KNN_model_auc, KNN_tuned3_auc, RF_model_auc, 
                                          RF_tuned_auc, CB_model_auc, CB_tuned_auc]})

compare = compare.sort_values(by="Recall_Score", ascending=True)
fig = px.bar(compare, x = "Recall_Score", y = "Model", title = "Recall_Score")
fig.show()

compare = compare.sort_values(by="F1_Score", ascending=True)
fig = px.bar(compare, x = "F1_Score", y = "Model", title = "F1_Score")
fig.show()

compare = compare.sort_values(by="Accuracy_Score", ascending=True)
fig = px.bar(compare, x = "Accuracy_Score", y = "Model", title = "Accuracy_Score")
fig.show()

compare = compare.sort_values(by="ROC_AUC_Score", ascending=True)
fig = px.bar(compare, x = "ROC_AUC_Score", y = "Model", title = "ROC_AUC_Score")
fig.show()

"""<a id="10"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">10) MODEL DEPLOYMENT<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

- Save and Export the Model as .pkl
- Save and Export Variables as .pkl 
---------

You cooked the food in the kitchen and moved on to the serving stage. The question is how do you showcase your work to others? Model Deployement helps you showcase your work to the world and make better decisions with it. But, deploying a model can get a little tricky at times. Before deploying the model, many things such as data storage, preprocessing, model building and monitoring need to be studied. Streamlit is a popular open source framework used by data scientists for model distribution.

Deployment of machine learning models, means making your models available to your other business systems. By deploying models, other systems can send data to them and get their predictions, which are in turn populated back into the company systems. Through machine learning model deployment, can begin to take full advantage of the model you built.

Data science is concerned with how to build machine learning models, which algorithm is more predictive, how to design features, and what variables to use to make the models more accurate. However, how these models are actually used is often neglected. And yet this is the most important step in the machine learning pipline. Only when a model is fully integrated with the business systems, real values â€‹â€‹can be extract from its predictions.

After doing the following operations in this notebook, jump to new .py file and create your web app with Streamlit.

<a id="10.1"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">10.1 - Save and Export the Model as .pkl<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>
"""

gradient_boosting_classifier = pickle.dump(GB_tuned, open('gradient_boosting_model', 'wb'))

kneighbors_classifier = pickle.dump(KNN_tuned3, open('kneighbors_model', 'wb'))

random_forest_classifier = pickle.dump(RF_tuned, open('random_forest_model', 'wb'))

catboost_classifier = pickle.dump(CB_tuned, open('catboost_model', 'wb'))

"""<a id="10.2"></a>
### <p style="background-color:#9452a5; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:LEFT; border-radius:10px 10px;">10.2 - Save and Export Variables as .pkl<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>
"""

df.head(3)

df1.head(3)

df2.head(3)

df.columns

df1.columns

df2.columns

col_lst = ['satisfaction_level', 'last_evaluation', 'number_project', 'average_montly_hours', 'time_spend_company', 
           'work_accident', 'promotion_last_5years', 'department_RandD', 'department_accounting', 'department_hr', 
           'department_management', 'department_marketing', 'department_product_mng', 'department_sales', 
           'department_support', 'department_technical', 'salary_low', 'salary_medium']

scaler = MinMaxScaler()
scaler_fitted = scaler.fit(df2[col_lst])
scaler_deploy = pickle.dump(scaler_fitted, open('scaler.sav', 'wb'))

"""### What will be done to deploy our Model

**1) Save you model using pickle (We did it in section 10.1).**

**2) Create a folder.**

**3) Inside the folder, create a .py extesion file which includes related codes for deployment and templates icluding index.htmml file if you will use flask for deployment(in our case we will use streamlit so we do NOT need it).**

**4) Put all related files including requirements.txt, all model files saved and images you will use in your .py file for deployment.**

**5) Sign in your account at https://aws.amazon.com/ and run your instance under ec2.**

**6) Open your Visual Studio Code IDE.**

**7) Make sure your Public IPv4 address at Open SSH configuratin file is the same as the one in your instance if you restart it again (If you change it do NOT forget to save).**

**8) Make a remote connection by connecting to Host via selecting related instance (Before doing this, if you wish, you can also publish the model at your local IP.).**

**9) After connecting the remote, put your folder by either "Open Folder" window or just drag and drop the folder.**
**10) Find and change your directory where your folder is by pwd, ls and cd commands.**

**11) Just run your .py file via streamlit run ".......".py (in our case streamlit run appN.py) (If there are NOT some libraries in your environment needed for deoployment or you need additional libraries for deployment please install them. Moreover, you have to need exact versions of libraries which you built your models with and needed for deployment).**

**12) Now you can see your deployment at External URL by clicking it.**

**13) However, you need a last step to be activated if you want it to be streamed even if you close your Visual Studio Code IDE.**

**14) Open and create a new tmux session via tmux and tmux new -s session_name, respectively (If you do NOT have Tmux package install it viaa sudo apt install tmux).**

**15) That's it! Now people enjoy your deployment and you can HAVE FUN...**

<a id="11"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">11) REFERENCES<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

- Kline, R.B. (2011). Principles and practice of structural equation modeling (5th ed., pp. 3-427). New York:The Guilford Press.
- Edwards, A. (1976). An introduction to linear regression and correlation. W. H. Freeman
- Everitt, B. S.; Skrondal, A. (2010), The Cambridge Dictionary of Statistics, Cambridge University Press.
- https://www.amazon.com/Python-Feature-Engineering-Cookbook-transforming/dp/1789806313/ref=sr_1_1?dchild=1&keywords=feature+engineering+cookbook&qid=1627628487&s=books&sr=1-1
- https://www.amazon.com/Feature-Engineering-Made-Easy-Identify-ebook/dp/B077N6MK5W
- https://www.amazon.com/Feature-Engineering-Selection-Chapman-Science/dp/1032090855/ref=sr_1_1?crid=19T9G95E1W7VJ&dchild=1&keywords=feature+engineering+and+selection+kuhn&qid=1628050948&sprefix=feature+engineering+and+%2Cdigital-text%2C293&sr=8-1
- https://www.amazon.com/Introduction-Machine-Learning-Python-Scientists/dp/1449369413
- Neural Networks from Scratch in Python (by Kinsley Â§ Kukiela) [external link text](https://nnfs.io/)
- Practical Statistics for Data Scientists (by Bruce & Gedeck) [external link text](https://www.amazon.com/Practical-Statistics-Data-Scientists-Essential/dp/149207294X/ref=sr_1_1?dchild=1&keywords=Practical+Statistics+for+Data+Scientists&qid=1627662007&sr=8-1)
- Applications of Deep Neural Networks(by Jeff Heaton) [external link text](https://arxiv.org/abs/2009.05673)
- Applied Predictive Modeling (by Kuhn & Johnson) [external link text](https://www.amazon.com/Applied-Predictive-Modeling-Max-Kuhn/dp/1461468485/ref=pd_sbs_3/141-4288971-3747365?pd_rd_w=AOIS7&pf_rd_p=3676f086-9496-4fd7-8490-77cf7f43f846&pf_rd_r=MCCHJXWK39VD6VW7RVAR&pd_rd_r=4ffcd1ea-44b9-4f33-b9b3-dc02ee159662&pd_rd_wg=nU1Ex&pd_rd_i=1461468485&psc=1:)
- Hands-On Machine Learning with Scikit-Learn, Keras, and TensorFlow (by AurÃ©lien GÃ©ron) [external link text](https://www.amazon.com/Hands-Machine-Learning-Scikit-Learn-TensorFlow/dp/1492032646/ref=sr_1_1?crid=2GV554Q2EKD1E&dchild=1&keywords=hands-on+machine+learning+with+scikit-learn%2C+keras%2C+and+tensorflow&qid=1627628294&s=books&sprefix=hands%2Cstripbooks-intl-ship%2C309&sr=1-1)
- Master Machine Learning Algorithms (by Brownlee, ML algorithms are very well explained ) [external link text](https://machinelearningmastery.com/master-machine-learning-algorithms/)
- Python Feature Engineering Cookbook (by Galli) [external link text](https://www.amazon.com/Python-Feature-Engineering-Cookbook-transforming/dp/1789806313/ref=sr_1_1?dchild=1&keywords=feature+engineering+cookbook&qid=1627628487&s=books&sr=1-1)
- Feature Engineering Made Easy (by Ozdemir & Susarla) [external link text](https://www.amazon.com/Feature-Engineering-Made-Easy-Identify-ebook/dp/B077N6MK5W)
- Feature Engineering and Selection (by Kuhn & Johnson) [external link text](https://www.amazon.com/Feature-Engineering-Selection-Chapman-Science/dp/1032090855/ref=sr_1_1?crid=19T9G95E1W7VJ&dchild=1&keywords=feature+engineering+and+selection+kuhn&qid=1628050948&sprefix=feature+engineering+and+%2Cdigital-text%2C293&sr=8-1)
- Imbalanced Classification with Python(by Brownlee) [external link text](https://machinelearningmastery.com/imbalanced-classification-with-python/)
- https://www.analyticsvidhya.com/blog/2021/06/generate-reports-using-pandas-profiling-deploy-using-streamlit/
- https://towardsdatascience.com/exploratory-data-analysis-with-pandas-profiling-de3aae2ddff3
- https://analyticsindiamag.com/why-data-scaling-is-important-in-machine-learning-how-to-effectively-do-it/
- https://www.analyticsvidhya.com/blog/2021/01/in-depth-intuition-of-k-means-clustering-algorithm-in-machine-learning/
- https://www.analyticsvidhya.com/blog/2021/01/in-depth-intuition-of-k-means-clustering-algorithm-in-machine-learning/
- https://www.kaggle.com/kadirduran/military-power-clustering
- https://www.analyticsvidhya.com/blog/2020/04/feature-scaling-machine-learning-normalization-standardization/
- https://machinelearningmastery.com/how-to-improve-neural-network-stability-and-modeling-performance-with-data-scaling/
- https://machinelearningmastery.com/how-to-stop-training-deep-neural-networks-at-the-right-time-using-early-stopping/#:~:text=Early%20stopping%20is%20a%20method,deep%20learning%20neural%20network%20models.
- https://www.sciencedirect.com/science/article/pii/S1556086415306043
- https://medium.com/machine-learning-t%C3%BCrkiye/crm-analizi-rfm-analizi-ve-cltv-m%C3%BC%C5%9Fteri-ya%C5%9Fam-boyu-de%C4%9Feri-36e5c3a232b1
- https://medium.com/capillary-data-science/rfm-analysis-an-effective-customer-segmentation-technique-using-python-58804480d232
- https://towardsdatascience.com/rfm-analysis-using-bigquery-ml-bfaa51b83086
- https://www.ticimax.com/blog/kohort-analizi-hakkinda-bilmeniz-gerekenler
- https://www.ibm.com/docs/en/spss-modeler/18.2.2?topic=node-rfm-analysis-settings
- https://www.kaggle.com/vijayuv/onlineretail
- https://www.putler.com/rfm-analysis/
- https://clevertap.com/blog/rfm-analysis/
- https://towardsdatascience.com/understanding-k-means-clustering-in-machine-learning-6a6e67336aa1
- https://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_silhouette_analysis.html
- https://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_silhouette_analysis.html
- https://medium.com/swlh/cohort-analysis-using-python-and-pandas-d2a60f4d0a4d
- https://en.wikipedia.org/wiki/Feature_engineering#:~:text=Feature%20engineering%20is%20the%20process,competitions%20and%20machine%20learning%20projects.
- https://towardsdatascience.com/feature-engineering-for-machine-learning-3a5e293a5114
- https://www.kdnuggets.com/2018/12/feature-engineering-explained.html
- https://machinelearningmastery.com/discover-feature-engineering-how-to-engineer-features-and-how-to-get-good-at-it/
- https://www.analyticsvidhya.com/blog/2021/03/step-by-step-process-of-feature-engineering-for-machine-learning-algorithms-in-data-science/
- https://clevertap.com/blog/cohort-analysis/

<a id="12"></a>
## <p style="background-color:#B61151; font-family:newtimeroman; color:#FFF9ED; font-size:150%; text-align:center; border-radius:10px 10px;">12) FURTHER READINGS<p>

<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Table of Contents</a>

- Kline, R.B. (2011). Principles and practice of structural equation modeling (5th ed., pp. 3-427). New York:The Guilford Press.
- Edwards, A. (1976). An introduction to linear regression and correlation. W. H. Freeman
- Everitt, B. S.; Skrondal, A. (2010), The Cambridge Dictionary of Statistics, Cambridge University Press.
- https://www.amazon.com/Python-Feature-Engineering-Cookbook-transforming/dp/1789806313/ref=sr_1_1?dchild=1&keywords=feature+engineering+cookbook&qid=1627628487&s=books&sr=1-1
- https://www.amazon.com/Feature-Engineering-Made-Easy-Identify-ebook/dp/B077N6MK5W
- https://www.amazon.com/Feature-Engineering-Selection-Chapman-Science/dp/1032090855/ref=sr_1_1?crid=19T9G95E1W7VJ&dchild=1&keywords=feature+engineering+and+selection+kuhn&qid=1628050948&sprefix=feature+engineering+and+%2Cdigital-text%2C293&sr=8-1
- https://www.amazon.com/Introduction-Machine-Learning-Python-Scientists/dp/1449369413
- Neural Networks from Scratch in Python (by Kinsley Â§ Kukiela) [external link text](https://nnfs.io/)
- Practical Statistics for Data Scientists (by Bruce & Gedeck) [external link text](https://www.amazon.com/Practical-Statistics-Data-Scientists-Essential/dp/149207294X/ref=sr_1_1?dchild=1&keywords=Practical+Statistics+for+Data+Scientists&qid=1627662007&sr=8-1)
- Applications of Deep Neural Networks(by Jeff Heaton) [external link text](https://arxiv.org/abs/2009.05673)
- Applied Predictive Modeling (by Kuhn & Johnson) [external link text](https://www.amazon.com/Applied-Predictive-Modeling-Max-Kuhn/dp/1461468485/ref=pd_sbs_3/141-4288971-3747365?pd_rd_w=AOIS7&pf_rd_p=3676f086-9496-4fd7-8490-77cf7f43f846&pf_rd_r=MCCHJXWK39VD6VW7RVAR&pd_rd_r=4ffcd1ea-44b9-4f33-b9b3-dc02ee159662&pd_rd_wg=nU1Ex&pd_rd_i=1461468485&psc=1:)
- Hands-On Machine Learning with Scikit-Learn, Keras, and TensorFlow (by AurÃ©lien GÃ©ron) [external link text](https://www.amazon.com/Hands-Machine-Learning-Scikit-Learn-TensorFlow/dp/1492032646/ref=sr_1_1?crid=2GV554Q2EKD1E&dchild=1&keywords=hands-on+machine+learning+with+scikit-learn%2C+keras%2C+and+tensorflow&qid=1627628294&s=books&sprefix=hands%2Cstripbooks-intl-ship%2C309&sr=1-1)
- Master Machine Learning Algorithms (by Brownlee, ML algorithms are very well explained ) [external link text](https://machinelearningmastery.com/master-machine-learning-algorithms/)
- Python Feature Engineering Cookbook (by Galli) [external link text](https://www.amazon.com/Python-Feature-Engineering-Cookbook-transforming/dp/1789806313/ref=sr_1_1?dchild=1&keywords=feature+engineering+cookbook&qid=1627628487&s=books&sr=1-1)
- Feature Engineering Made Easy (by Ozdemir & Susarla) [external link text](https://www.amazon.com/Feature-Engineering-Made-Easy-Identify-ebook/dp/B077N6MK5W)
- Feature Engineering and Selection (by Kuhn & Johnson) [external link text](https://www.amazon.com/Feature-Engineering-Selection-Chapman-Science/dp/1032090855/ref=sr_1_1?crid=19T9G95E1W7VJ&dchild=1&keywords=feature+engineering+and+selection+kuhn&qid=1628050948&sprefix=feature+engineering+and+%2Cdigital-text%2C293&sr=8-1)
- Imbalanced Classification with Python(by Brownlee) [external link text](https://machinelearningmastery.com/imbalanced-classification-with-python/)
- https://www.kaggle.com/kaanboke/the-most-common-evaluation-metrics-a-gentle-intro
"""